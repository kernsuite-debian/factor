pipeline.steps = [update_mapfile_hosts, create_ms_map, create_msmulti_map, create_parmdb_map, create_full_skymodels_map, make_facet_skymodels_cal, make_sourcedb_cal_facet_sources, expand_sourcedb_cal_facet_sources, shift_cal, create_compressed_mapfile, sort_into_Groups, sort_into_Groups_maps, concat_data, concat_data_compressed_mapfile, {% if selfcal_local_dir is not none %} make_concat_data_sync_mapfile, sync_concat_data_to_local, {% endif %} make_fast_phase_parmdb_map, create_peel_skymodel_map, make_peel_sourcedb, expand_peel_sourcedb_map, remove_parmdbs11, solve_ampphase11, apply_ampphase11, merge_phase_parmdbs, make_slow_gain_parmdb_map, remove_parmdbs12, solve_ampphase12, merge_amp_parmdbs, smooth_amps, smooth_amps_normalized, {% if selfcal_local_dir is not none %} remove_concat_data, {% endif %} merge_selfcal_parmdbs, convert_merged_selfcal_parmdbs, merge_normalized_selfcal_parmdbs, convert_normalized_merged_selfcal_parmdbs, {% if create_preapply_parmdb %} create_preapply_parmdb, {% endif %} make_selfcal_plots, expand_merged_parmdb_map, expand_normalized_merged_parmdb_map, expand_cal_sourcedb_map, {% if not is_patch %} make_facet_skymodels_all, make_sourcedb_all_facet_sources, expand_sourcedb_all_facet_sources, prepare_imaging_data, create_compressed_mapfile5, premask, wsclean_image_full, create_imagebase_map, adjust_wsclean_mapfile1, mask5, check_mask_high, create_model5_map, expand_model5_map, expand_mask5_map, make_high_facet_skymodel, make_sourcedb_high, expand_sourcedb_high, subtract_high, create_compressed_mapfile6, premask_med, wsclean_image_full_med, create_imagebase_med_map, adjust_wsclean_mapfile3, mask6, check_mask_med, expand_model6_map, expand_mask6_map, make_med_facet_skymodel, combine_facet_skymodels, make_sourcedb_new_facet_sources_for_facet_imaging, expand_sourcedb_new_facet_sources, {% endif %} predict_and_difference_models, create_middle_band_mapfile1, create_middle_band_mapfile2, subtract_single, average_pre, average_post, average_pre_compressed_map, wsclean_pre, average_post_compressed_map, wsclean_post, verify_subtract]

pipeline.pluginpath = {{ pipeline_dir }}/plugins

update_mapfile_hosts.control.kind        = plugin
update_mapfile_hosts.control.type        = updateHosts
update_mapfile_hosts.control.mapfile_dir = input.output.mapfile_dir
update_mapfile_hosts.control.hosts       = {{ hosts }}

# create a mapfile with all single MSs from supplied list, length = nfiles
create_ms_map.control.kind        = plugin
create_ms_map.control.type        = addListMapfile
create_ms_map.control.hosts       = {{ hosts }}
create_ms_map.control.files       = {{ ms_files_single }}
create_ms_map.control.mapfile_dir = input.output.mapfile_dir
create_ms_map.control.filename    = input_files_single.mapfile

# create a multi-mapfile with the groups of MSs from supplied list, length = nbands
create_msmulti_map.control.kind        = plugin
create_msmulti_map.control.type        = addListMultiMapfile
create_msmulti_map.control.hosts       = {{ hosts }}
create_msmulti_map.control.files       = {{ ms_files_grouped }}
create_msmulti_map.control.mapfile_dir = input.output.mapfile_dir
create_msmulti_map.control.filename    = input_files_grouped.mapfile

# create a mapfile with the direction-independent parmDBs from supplied list, length = nfiles
create_parmdb_map.control.kind        = plugin
create_parmdb_map.control.type        = addListMapfile
create_parmdb_map.control.hosts       = {{ hosts }}
create_parmdb_map.control.files       = {{ dir_indep_parmDBs }}
create_parmdb_map.control.mapfile_dir = input.output.mapfile_dir
create_parmdb_map.control.filename    = dir_indep_instrument_parmdbs.mapfile

# create a mapfile with the current skymodels from supplied list, length = nbands
create_full_skymodels_map.control.kind        = plugin
create_full_skymodels_map.control.type        = addListMapfile
create_full_skymodels_map.control.hosts       = {{ hosts }}
create_full_skymodels_map.control.files       = {{ skymodels }}
create_full_skymodels_map.control.mapfile_dir = input.output.mapfile_dir
create_full_skymodels_map.control.filename    = full_skymodels.mapfile

# extract the skymodel for the calibrator of this facet from global skymodel, length = nbands
make_facet_skymodels_cal.control.type       = make_facet_skymodel
make_facet_skymodels_cal.control.mapfile_in = create_full_skymodels_map.output.mapfile
make_facet_skymodels_cal.control.inputkey   = fullmodelfile
make_facet_skymodels_cal.control.outputkey  = outfile
make_facet_skymodels_cal.argument.flags     = [fullmodelfile,outfile,{{ vertices_file }}]
make_facet_skymodels_cal.argument.cal_only  = True

# convert the facet skymodel into a sourcedb, length = nbands
make_sourcedb_cal_facet_sources.control.type       = make_sourcedb
make_sourcedb_cal_facet_sources.control.mapfile_in = make_facet_skymodels_cal.output.mapfile
make_sourcedb_cal_facet_sources.control.inputkey   = in
make_sourcedb_cal_facet_sources.argument.format    = <
make_sourcedb_cal_facet_sources.argument.outtype   = blob
make_sourcedb_cal_facet_sources.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_cal_facet_sources.control.kind           = plugin
expand_sourcedb_cal_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_cal_facet_sources.control.mapfile_in     = make_sourcedb_cal_facet_sources.output.mapfile
expand_sourcedb_cal_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_cal_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_cal_facet_sources.control.filename       = expand_sourcedb_cal_facet_sources.mapfile

# shift data to calibrator position, predict and add calibrator sources, and average in frequency, length = nfiles
# Compress both data and weights
shift_cal.control.type                                 = dppp
shift_cal.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
shift_cal.control.inputkeys                            = [msin,sourcedb,dir_indep_parmdb]
shift_cal.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
shift_cal.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
shift_cal.argument.msout.overwrite                     = True
shift_cal.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
shift_cal.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
shift_cal.argument.steps                               = [shift,add,flag,avg]
{% else %}
shift_cal.argument.steps                               = [shift,add,avg]
{% endif %}
shift_cal.argument.shift.type                          = phaseshifter
shift_cal.argument.shift.phasecenter                   = [{{ ra }}deg, {{ dec }}deg]
shift_cal.argument.add.type                            = predict
shift_cal.argument.add.sourcedb                        = sourcedb
shift_cal.argument.add.operation                       = add
shift_cal.argument.add.applycal.parmdb                 = dir_indep_parmdb
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
shift_cal.argument.flag.type                           = preflagger
shift_cal.argument.flag.expr                           = {{ flag_expr }}
{% endif %}
{% if flag_abstime is not none %}
shift_cal.argument.flag.flag_abstime.abstime           = {{ flag_abstime }}
{% endif %}
{% if flag_baseline is not none %}
shift_cal.argument.flag.flag_baseline.baseline         = {{ flag_baseline }}
{% endif %}
{% if flag_freqrange is not none %}
shift_cal.argument.flag.flag_freqrange.freqrange       = {{ flag_freqrange }}
{% endif %}
shift_cal.argument.avg.type                            = squash
shift_cal.argument.avg.freqstep                        = {{ facetselfcal_freqstep }}
shift_cal.argument.avg.timestep                        = 1
{% if use_compression %}
shift_cal.argument.msout.storagemanager                = "Dysco"
shift_cal.argument.msout.storagemanager.databitrate    = 16
shift_cal.argument.msout.storagemanager.weightbitrate  = 12
shift_cal.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
shift_cal.argument.msout.storagemanager.disttruncation = 1.5
shift_cal.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile.control.kind        = plugin
create_compressed_mapfile.control.type        = compressMapfile
create_compressed_mapfile.control.mapfile_in  = shift_cal.output.mapfile
create_compressed_mapfile.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile.control.filename    = concat_averaged_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes * num_cal_blocks
# we make dummy data here so that there will always be MS files for wsclean
# predict, even if a cal block is completely flagged (which otherwise would get
# skipped and cause problems with predict)
sort_into_Groups.control.type                 = sort_times_into_freqGroups
sort_into_Groups.argument.flags               = [create_compressed_mapfile.output.mapfile]
sort_into_Groups.argument.filename            = sorted_groups.mapfile
sort_into_Groups.argument.mapfile_dir         = input.output.mapfile_dir
sort_into_Groups.argument.hosts               = {{ hosts }}
sort_into_Groups.argument.stepname            = sort_into_Groups
sort_into_Groups.argument.enforce_numSB       = False
{% if num_cal_blocks > 1 %}
sort_into_Groups.argument.numSB               = {{ num_bands_per_cal_block }}
{% endif %}
sort_into_Groups.argument.nband_pad           = {{ nband_pad_selfcal }}
sort_into_Groups.argument.make_dummy_files    = True
sort_into_Groups.argument.skip_flagged_groups = False

# convert the output of sort_into_Groups into usable mapfiles, len = 1 / (ntimes * num_cal_blocks)
sort_into_Groups_maps.control.kind             = plugin
sort_into_Groups_maps.control.type             = mapfilenamesFromMapfiles
sort_into_Groups_maps.control.mapfile_groupmap = sort_into_Groups.output.groupmapfile.mapfile
sort_into_Groups_maps.control.mapfile_filesmap = sort_into_Groups.output.mapfile.mapfile

# concat data in frequency, length = ntimes * num_cal_blocks
# Note, this step is done because DPPP cannot handle datasets with multiple spectral
# windows, as occurs when MSs at several frequencies are virtually concatenated
# Compress both data and weights
concat_data.control.type                                 = dppp
concat_data.control.mapfile_out                          = sort_into_Groups_maps.output.groupmap
concat_data.control.mapfile_in                           = sort_into_Groups_maps.output.filesmap
concat_data.control.inputkey                             = msin
concat_data.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
concat_data.argument.msin.datacolumn                     = DATA
concat_data.argument.msin.missingdata                    = True
concat_data.argument.msin.orderms                        = False
concat_data.argument.msout.overwrite                     = True
concat_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
concat_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
concat_data.argument.steps                               = []
{% if use_compression %}
concat_data.argument.msout.storagemanager                = "Dysco"
concat_data.argument.msout.storagemanager.databitrate    = 16
concat_data.argument.msout.storagemanager.weightbitrate  = 12
concat_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
concat_data.argument.msout.storagemanager.disttruncation = 1.5
concat_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile for concatenated data MSs, length = 1
concat_data_compressed_mapfile.control.kind        = plugin
concat_data_compressed_mapfile.control.type        = compressMapfile
concat_data_compressed_mapfile.control.mapfile_in  = concat_data.output.mapfile
concat_data_compressed_mapfile.control.mapfile_dir = input.output.mapfile_dir
concat_data_compressed_mapfile.control.filename    = concat_chunks_input.mapfile

{% if selfcal_local_dir is not none %}
# make a mapfile for syncing of concat_data to selfcal_local_dir, len = ntimes * num_cal_blocks
make_concat_data_sync_mapfile.control.kind         = plugin
make_concat_data_sync_mapfile.control.type         = changeDirectory
make_concat_data_sync_mapfile.control.mapfile_in   = concat_data.output.mapfile
make_concat_data_sync_mapfile.control.new_dir      = {{ selfcal_local_dir }}
make_concat_data_sync_mapfile.control.make_tempdir = True
make_concat_data_sync_mapfile.control.mapfile_dir  = input.output.mapfile_dir
make_concat_data_sync_mapfile.control.filename     = concat_data_local.mapfile

# copy the output of concat_data to selfcal_local_dir, len = ntimes * num_cal_blocks
sync_concat_data_to_local.control.type        = sync_files
sync_concat_data_to_local.control.mapfile_in  = concat_data.output.mapfile
sync_concat_data_to_local.control.mapfile_out = make_concat_data_sync_mapfile.output.mapfile
sync_concat_data_to_local.control.inputkey    = msin
sync_concat_data_to_local.control.outputkey   = msout
sync_concat_data_to_local.argument.flags      = [msin,msout]
{% endif %}

# generate mapfile for the fast-phase parmDBs generated in the solve_ampphase11 step, length = ntimes * num_cal_blocks
make_fast_phase_parmdb_map.control.kind               =  plugin
make_fast_phase_parmdb_map.control.type               =  createMapfile
make_fast_phase_parmdb_map.control.method             =  add_suffix_to_file
make_fast_phase_parmdb_map.control.mapfile_in         =  concat_data.output.mapfile
make_fast_phase_parmdb_map.control.add_suffix_to_file =  /instrument
make_fast_phase_parmdb_map.control.mapfile_dir        =  input.output.mapfile_dir
make_fast_phase_parmdb_map.control.filename           =  fast_parmdb.mapfile

# create a mapfile with the outlier skymodel from supplied list, length = 1
create_peel_skymodel_map.control.kind        = plugin
create_peel_skymodel_map.control.type        = addListMapfile
create_peel_skymodel_map.control.hosts       = {{ hosts }}
create_peel_skymodel_map.control.files       = [{{ peel_skymodel }}]
create_peel_skymodel_map.control.mapfile_dir = input.output.mapfile_dir
create_peel_skymodel_map.control.filename    = peel_skymodel.mapfile

# convert the outlier skymodel into a sourcedb, length = 1
make_peel_sourcedb.control.type       = make_sourcedb
make_peel_sourcedb.control.mapfile_in = create_peel_skymodel_map.output.mapfile
make_peel_sourcedb.control.inputkey   = in
make_peel_sourcedb.argument.format    = <
make_peel_sourcedb.argument.outtype   = blob
make_peel_sourcedb.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_peel_sourcedb_map.control.kind             = plugin
expand_peel_sourcedb_map.control.type             = expandMapfile
expand_peel_sourcedb_map.control.mapfile_in       = make_peel_sourcedb.output.mapfile
expand_peel_sourcedb_map.control.mapfile_to_match = concat_data.output.mapfile
expand_peel_sourcedb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_peel_sourcedb_map.control.filename         = expand_peel_sourcedb.mapfile

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs11.control.type       = remove_file
remove_parmdbs11.control.mapfile_in = make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs11.control.inputkey   = parmdb
remove_parmdbs11.argument.flags     = [-rf,parmdb]

# run GainCal with peel sourcedb on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase11.control.type                     = dppp_inplace
solve_ampphase11.control.mapfiles_in              = [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile,expand_peel_sourcedb_map.output.mapfile]
solve_ampphase11.control.inputkeys                = [msin,parmdb,sourcedb]
solve_ampphase11.argument.numthreads              = {{ max_cpus_per_proc_ntimes }}
solve_ampphase11.argument.msin.datacolumn         = DATA
solve_ampphase11.argument.msout                   = .
solve_ampphase11.argument.steps                   = [uvcut,solvetec]
solve_ampphase11.argument.uvcut.type              = uvwflagger
solve_ampphase11.argument.uvcut.uvlambdamin       = {{ solve_min_uv_lambda }}
solve_ampphase11.argument.solvetec.type           = gaincal
solve_ampphase11.argument.solvetec.caltype        = tecandphase
solve_ampphase11.argument.solvetec.parmdb         = parmdb
solve_ampphase11.argument.solvetec.usemodelcolumn = False
solve_ampphase11.argument.solvetec.sourcedb       = sourcedb
solve_ampphase11.argument.solvetec.solint         = {{ solint_time_p }}
solve_ampphase11.argument.solvetec.nchan          = {{ solint_freq_a }}

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase11.control.type                                 = dppp_inplace
apply_ampphase11.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_ampphase11.control.inputkeys                            = [msin,parmdb]
apply_ampphase11.argument.numthreads                          = {{ max_cpus_per_proc_ntimes }}
apply_ampphase11.argument.msin.datacolumn                     = DATA
apply_ampphase11.argument.msout                               = .
apply_ampphase11.argument.msout.datacolumn                    = CORRECTED_DATA
apply_ampphase11.argument.steps                               = [correct_fast1,correct_fast2]
apply_ampphase11.argument.correct_fast1.type                  = applycal
apply_ampphase11.argument.correct_fast1.parmdb                = parmdb
apply_ampphase11.argument.correct_fast1.correction            = tec
apply_ampphase11.argument.correct_fast1.invert                = True
apply_ampphase11.argument.correct_fast2.type                  = applycal
apply_ampphase11.argument.correct_fast2.parmdb                = parmdb
apply_ampphase11.argument.correct_fast2.correction            = commonscalarphase
apply_ampphase11.argument.correct_fast2.invert                = True
{% if use_compression %}
apply_ampphase11.argument.msout.storagemanager                = "Dysco"
apply_ampphase11.argument.msout.storagemanager.databitrate    = 16
apply_ampphase11.argument.msout.storagemanager.weightbitrate  = 12
apply_ampphase11.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_ampphase11.argument.msout.storagemanager.disttruncation = 1.5
apply_ampphase11.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# merge the parmDBs with the phase solutions into one, length = 1
merge_phase_parmdbs.control.type       = merge_parmdbs_in_time
merge_phase_parmdbs.control.mapfile_in = concat_data_compressed_mapfile.output.mapfile
merge_phase_parmdbs.control.inputkey   = mslist
merge_phase_parmdbs.control.outputkey  = outparmdb
merge_phase_parmdbs.argument.flags     = [mslist,instrument,outparmdb]

# generate mapfile for the slow-gain parmDBs generated in the solve_ampphase12 step, length = ntimes * num_cal_blocks
make_slow_gain_parmdb_map.control.kind               =  plugin
make_slow_gain_parmdb_map.control.type               =  createMapfile
make_slow_gain_parmdb_map.control.method             =  add_suffix_to_file
make_slow_gain_parmdb_map.control.mapfile_in         =  concat_data.output.mapfile
make_slow_gain_parmdb_map.control.add_suffix_to_file =  /instrument_slow
make_slow_gain_parmdb_map.control.mapfile_dir        =  input.output.mapfile_dir
make_slow_gain_parmdb_map.control.filename           =  slow_parmdb.mapfile

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs12.control.type       = remove_file
remove_parmdbs12.control.mapfile_in = make_slow_gain_parmdb_map.output.mapfile
remove_parmdbs12.control.inputkey   = parmdb
remove_parmdbs12.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase12.control.type                = dppp_inplace
solve_ampphase12.control.mapfiles_in         = [{{ concat_data_mapfile }},make_slow_gain_parmdb_map.output.mapfile,expand_peel_sourcedb_map.output.mapfile]
solve_ampphase12.control.inputkeys           = [msin,parmdb,sourcedb]
solve_ampphase12.argument.numthreads         = {{ max_cpus_per_io_proc_ntimes }}
solve_ampphase12.argument.msin.datacolumn    = CORRECTED_DATA
solve_ampphase12.argument.msout              = .
solve_ampphase12.argument.steps              = [uvcut,solvegain]
solve_ampphase12.argument.uvcut.type         = uvwflagger
solve_ampphase12.argument.uvcut.uvlambdamin  = {{ solve_min_uv_lambda }}
solve_ampphase12.argument.solvegain.type     = gaincal
solve_ampphase12.argument.solvegain.caltype  = {{ selfcal_caltype }}
solve_ampphase12.argument.solvegain.parmdb   = parmdb
solve_ampphase12.argument.solvegain.sourcedb = sourcedb
solve_ampphase12.argument.solvegain.solint   = {{ solint_time_a }}
solve_ampphase12.argument.solvegain.nchan    = {{ solint_freq_a }}

# merge the parmDBs with the amplitude solutions into one, length = 1
merge_amp_parmdbs.control.type         = merge_parmdbs_in_time
merge_amp_parmdbs.control.mapfile_in   = concat_data_compressed_mapfile.output.mapfile
merge_amp_parmdbs.control.inputkey     = mslist
merge_amp_parmdbs.control.outputkey    = outparmdb
merge_amp_parmdbs.argument.flags       = [mslist,instrument_slow,outparmdb]
{% if selfcal_local_dir is not none %}
merge_amp_parmdbs.argument.scratch_dir = {{ selfcal_local_dir }}
{% endif %}

# Smooth the amplitude solutions, but do not normalize them as the sky model is  // length = 1
# in absolute flux and not apparent flux
smooth_amps.control.type       = {{ smooth_amps_task }}
smooth_amps.control.mapfile_in = merge_amp_parmdbs.output.mapfile
smooth_amps.control.inputkey   = ampparmdb
smooth_amps.control.outputkey  = outparmdb
smooth_amps.control.arguments  = [ampparmdb,outparmdb]
smooth_amps.argument.normalize = False

# Now smooth the amplitude solutions and normalize them (for use later during
# imaging of facets for peeled calibrators), length = 1
smooth_amps_normalized.control.type         = {{ smooth_amps_task }}
smooth_amps_normalized.control.mapfile_in   = merge_amp_parmdbs.output.mapfile
smooth_amps_normalized.control.inputkey     = ampparmdb
smooth_amps_normalized.control.outputkey    = outparmdb
smooth_amps_normalized.control.arguments    = [ampparmdb,outparmdb]
smooth_amps_normalized.argument.normalize   = True
{% if selfcal_local_dir is not none %}
smooth_amps_normalized.argument.scratch_dir = {{ selfcal_local_dir }}
{% endif %}

{% if selfcal_local_dir is not none %}
# remove concat_data files, length = ntimes * num_cal_blocks
remove_concat_data.control.type       = remove_synced_data
remove_concat_data.control.mapfile_in = make_concat_data_sync_mapfile.output.mapfile
remove_concat_data.control.inputkey   = msfile
remove_concat_data.argument.flags     = [msfile]
{% endif %}

# merge the phases and amplitudes parmDBs, length = 1
merge_selfcal_parmdbs.control.type        = merge_parmdbs_selfcal
merge_selfcal_parmdbs.control.mapfiles_in = [merge_phase_parmdbs.output.mapfile,smooth_amps.output.mapfile]
merge_selfcal_parmdbs.control.inputkeys   = [parmdb_p,parmdb_a]
merge_selfcal_parmdbs.control.outputkey   = parmdb_out
merge_selfcal_parmdbs.argument.flags      = [parmdb_p,parmdb_a,parmdb_out]

# convert the merged phase and amplitude parmDBs to gain parmDBs, length = 1
convert_merged_selfcal_parmdbs.control.type         = convert_solutions_to_gain
convert_merged_selfcal_parmdbs.control.mapfiles_in  = [merge_phase_parmdbs.output.mapfile,smooth_amps.output.mapfile]
convert_merged_selfcal_parmdbs.control.inputkeys    = [fast_parmdb_in,slow_parmdb_in]
convert_merged_selfcal_parmdbs.control.outputkey    = parmdb_out
convert_merged_selfcal_parmdbs.argument.flags       = [fast_parmdb_in,slow_parmdb_in,parmdb_out]
{% if selfcal_local_dir is not none %}
convert_merged_selfcal_parmdbs.argument.scratch_dir = {{ selfcal_local_dir }}
{% endif %}

# merge the phases and normalized amplitudes parmDBs, length = 1
merge_normalized_selfcal_parmdbs.control.type        = merge_parmdbs_selfcal
merge_normalized_selfcal_parmdbs.control.mapfiles_in = [merge_phase_parmdbs.output.mapfile,smooth_amps_normalized.output.mapfile]
merge_normalized_selfcal_parmdbs.control.inputkeys   = [parmdb_p,parmdb_a]
merge_normalized_selfcal_parmdbs.control.outputkey   = parmdb_out
merge_normalized_selfcal_parmdbs.argument.flags      = [parmdb_p,parmdb_a,parmdb_out]

# convert the merged phase and normalized amplitude parmDBs to gain parmDBs, length = 1
convert_normalized_merged_selfcal_parmdbs.control.type         = convert_solutions_to_gain
convert_normalized_merged_selfcal_parmdbs.control.mapfiles_in  = [merge_phase_parmdbs.output.mapfile,smooth_amps_normalized.output.mapfile]
convert_normalized_merged_selfcal_parmdbs.control.inputkeys    = [fast_parmdb_in,slow_parmdb_in]
convert_normalized_merged_selfcal_parmdbs.control.outputkey    = parmdb_out
convert_normalized_merged_selfcal_parmdbs.argument.flags       = [fast_parmdb_in,slow_parmdb_in,parmdb_out]
{% if selfcal_local_dir is not none %}
convert_normalized_merged_selfcal_parmdbs.argument.scratch_dir = {{ selfcal_local_dir }}
{% endif %}

{% if create_preapply_parmdb %}
# make a phase-only parmDB suitable for preapplication, length = 1
create_preapply_parmdb.control.type       = reset_amps
create_preapply_parmdb.control.mapfile_in = convert_merged_selfcal_parmdbs.output.mapfile
create_preapply_parmdb.control.inputkey   = inparmdb
create_preapply_parmdb.control.outputkey  = outparmdb
create_preapply_parmdb.control.arguments  = [inparmdb,outparmdb]
{% endif %}

# make plots of the selfcal results (normalized) from the merged parmDB, length = 1
make_selfcal_plots.control.type       = make_selfcal_plots
make_selfcal_plots.control.mapfile_in = merge_normalized_selfcal_parmdbs.output.mapfile
make_selfcal_plots.control.inputkeys  = parmdb
make_selfcal_plots.control.outputkey  = plots_root
make_selfcal_plots.argument.flags     = [parmdb,plots_root]
make_selfcal_plots.argument.fourpol   = {{ fourpol }}

# expand the merged parmDB to all files, length = nfiles
expand_merged_parmdb_map.control.kind             = plugin
expand_merged_parmdb_map.control.type             = expandMapfile
expand_merged_parmdb_map.control.mapfile_in       = convert_merged_selfcal_parmdbs.output.mapfile
expand_merged_parmdb_map.control.mapfile_to_match = shift_cal.output.mapfile
expand_merged_parmdb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_merged_parmdb_map.control.filename         = expand_merged_parmdbs.mapfile

# expand the normalized merged parmDB to all files, length = nfiles
expand_normalized_merged_parmdb_map.control.kind             = plugin
expand_normalized_merged_parmdb_map.control.type             = expandMapfile
expand_normalized_merged_parmdb_map.control.mapfile_in       = convert_normalized_merged_selfcal_parmdbs.output.mapfile
expand_normalized_merged_parmdb_map.control.mapfile_to_match = shift_cal.output.mapfile
expand_normalized_merged_parmdb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_normalized_merged_parmdb_map.control.filename         = expand_normalized_merged_parmdbs.mapfile

# expand the calibrator peeling sourcedb to all files, length = nfiles
expand_cal_sourcedb_map.control.kind             = plugin
expand_cal_sourcedb_map.control.type             = expandMapfile
expand_cal_sourcedb_map.control.mapfile_in       = make_peel_sourcedb.output.mapfile
expand_cal_sourcedb_map.control.mapfile_to_match = shift_cal.output.mapfile
expand_cal_sourcedb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_cal_sourcedb_map.control.filename         = expand_sourcedb_outlier.mapfile

{% if not is_patch %}
# here we subtract the calibrator, add back the other facet sources and image

# extract the skymodel for the full facet from global skymodel, length = nbands
make_facet_skymodels_all.control.type       = make_facet_skymodel
make_facet_skymodels_all.control.mapfile_in = create_full_skymodels_map.output.mapfile
make_facet_skymodels_all.control.inputkey   = fullmodelfile
make_facet_skymodels_all.control.outputkey  = outfile
make_facet_skymodels_all.argument.flags     = [fullmodelfile,outfile,{{ vertices_file }}]

# convert the facet skymodel into a sourcedb, length = nbands
make_sourcedb_all_facet_sources.control.type       = make_sourcedb
make_sourcedb_all_facet_sources.control.mapfile_in = make_facet_skymodels_all.output.mapfile
make_sourcedb_all_facet_sources.control.inputkey   = in
make_sourcedb_all_facet_sources.argument.format    = <
make_sourcedb_all_facet_sources.argument.outtype   = blob
make_sourcedb_all_facet_sources.argument.append    = False

# expand the dir-indep sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_all_facet_sources.control.kind           = plugin
expand_sourcedb_all_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_all_facet_sources.control.mapfile_in     = make_sourcedb_all_facet_sources.output.mapfile
expand_sourcedb_all_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_all_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_all_facet_sources.control.filename       = expand_sourcedb_all_facet_sources.mapfile

# shift the empty data, add all facet sources, apply the direction-dependent solutions and average, length = nfiles
# compress data and weights
prepare_imaging_data.control.type                                 = dppp
prepare_imaging_data.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_all_facet_sources.output.mapfile,expand_cal_sourcedb_map.output.mapfile,create_parmdb_map.output.mapfile,expand_merged_parmdb_map.output.mapfile,expand_normalized_merged_parmdb_map.output.mapfile]
prepare_imaging_data.control.inputkeys                            = [msin,sourcedb,sourcedb_cal,dir_indep_parmdb,dir_dep_parmdb,dir_dep_parmdb_normalized]
prepare_imaging_data.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
prepare_imaging_data.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
prepare_imaging_data.argument.msin.startchan                      = {{ startchan_selfcal_facet_image }}
prepare_imaging_data.argument.msin.nchan                          = {{ nchan_selfcal_facet_image }}
prepare_imaging_data.argument.msout.overwrite                     = True
prepare_imaging_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
prepare_imaging_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
prepare_imaging_data.argument.steps                               = [shift,add,subtract_cal,flag,correct,flagzero,avg]
{% else %}
prepare_imaging_data.argument.steps                               = [shift,add,subtract_cal,correct,flagzero,avg]
{% endif %}
prepare_imaging_data.argument.shift.type                          = phaseshifter
prepare_imaging_data.argument.shift.phasecenter                   = [{{ facet_ra }}deg, {{ facet_dec }}deg]
prepare_imaging_data.argument.add.type                            = predict
prepare_imaging_data.argument.add.sourcedb                        = sourcedb
prepare_imaging_data.argument.add.operation                       = add
prepare_imaging_data.argument.add.applycal.parmdb                 = dir_indep_parmdb
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
prepare_imaging_data.argument.flag.type                             = preflagger
prepare_imaging_data.argument.flag.expr                           = {{ flag_expr }}
{% endif %}
{% if flag_abstime is not none %}
prepare_imaging_data.argument.flag.flag_abstime.abstime           = {{ flag_abstime }}
{% endif %}
{% if flag_baseline is not none %}
prepare_imaging_data.argument.flag.flag_baseline.baseline         = {{ flag_baseline }}
{% endif %}
{% if flag_freqrange is not none %}
prepare_imaging_data.argument.flag.flag_freqrange.freqrange       = {{ flag_freqrange }}
{% endif %}
prepare_imaging_data.argument.subtract_cal.type                   = predict
prepare_imaging_data.argument.subtract_cal.sourcedb               = sourcedb_cal
prepare_imaging_data.argument.subtract_cal.operation              = subtract
prepare_imaging_data.argument.subtract_cal.applycal.parmdb        = dir_dep_parmdb
prepare_imaging_data.argument.correct.type                        = applycal
prepare_imaging_data.argument.correct.parmdb                      = dir_dep_parmdb_normalized
prepare_imaging_data.argument.correct.invert                      = True
prepare_imaging_data.argument.flagzero.type                       = preflagger
prepare_imaging_data.argument.flagzero.amplmin                    = 1e-20
prepare_imaging_data.argument.avg.type                            = squash
prepare_imaging_data.argument.avg.freqstep                        = {{ facetimage_freqstep }}
prepare_imaging_data.argument.avg.timestep                        = {{ facetimage_timestep }}
{% if use_compression %}
prepare_imaging_data.argument.msout.storagemanager                = "Dysco"
prepare_imaging_data.argument.msout.storagemanager.databitrate    = 16
prepare_imaging_data.argument.msout.storagemanager.weightbitrate  = 12
prepare_imaging_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
prepare_imaging_data.argument.msout.storagemanager.disttruncation = 1.5
prepare_imaging_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile5.control.kind        = plugin
create_compressed_mapfile5.control.type        = compressMapfile
create_compressed_mapfile5.control.mapfile_in  = prepare_imaging_data.output.mapfile
create_compressed_mapfile5.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile5.control.filename    = concat_averaged_input.mapfile

# make a facet clean mask from the last selfcal image, length = 1
premask.control.type                   = make_clean_mask
premask.control.mapfile_in             = create_compressed_mapfile5.output.mapfile
premask.control.inputkey               = imagefile
premask.control.outputkey              = maskfile
premask.argument.flags                 = [imagefile,maskfile]
premask.argument.img_format            = fits
premask.argument.pad_to_size           = {{ facet_imsize }}
premask.argument.skip_source_detection = True
premask.argument.vertices_file         = {{ vertices_file }}
premask.argument.exclude_cal_region    = True
premask.argument.reference_ra_deg      = {{ facet_ra }}
premask.argument.reference_dec_deg     = {{ facet_dec }}
premask.argument.cellsize_deg          = {{ cellsize_selfcal_deg }}
premask.argument.make_blank_image      = True

# image the concatenated data with the preliminary mask, length = 1
wsclean_image_full.control.type                   = wsclean
wsclean_image_full.control.mapfiles_in            = [create_compressed_mapfile5.output.mapfile,premask.output.mapfile]
wsclean_image_full.control.inputkeys              = [msfile,fitsmask]
{% if nbands_selfcal_facet_image > 1 %}
wsclean_image_full.argument.flags                 = [-no-update-model-required,-fitbeam,-reorder,-joinchannels,-multiscale,-save-source-list,-local-rms,msfile]
wsclean_image_full.argument.channelsout           = {{ nbands_selfcal_facet_image }}
{% else %}
wsclean_image_full.argument.flags                 = [-no-update-model-required,-fitbeam,-reorder,-multiscale,-save-source-list,-local-rms,msfile]
{% endif %}
wsclean_image_full.argument.fitsmask              = fitsmask
wsclean_image_full.argument.size                  = {{ facet_imsize }} {{ facet_imsize }}
wsclean_image_full.argument.niter                 = {{ wsclean_selfcal_full_image_niter }}
wsclean_image_full.argument.pol                   = I
wsclean_image_full.argument.weight                = briggs {{ robust_selfcal }}
wsclean_image_full.argument.mgain                 = 0.8
wsclean_image_full.argument.minuv-l               = {{ facet_min_uv_lambda }}
wsclean_image_full.argument.scale                 = {{ cellsize_selfcal_deg }}
wsclean_image_full.argument.mem                   = {{ max_percent_memory_per_proc_single }}
wsclean_image_full.argument.j                     = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image_full.argument.tempdir               = {{ local_dir_parent }}
{% endif %}
{% if nbands_selfcal_facet_image > 5 %}
wsclean_image_full.argument.fit-spectral-pol      = 5
{% elif nbands_selfcal_facet_image > 1 %}
wsclean_image_full.argument.fit-spectral-pol      = {{ nbands_selfcal_facet_image - 1 }}
{% endif %}
wsclean_image_full.argument.multiscale-scales     = 0
wsclean_image_full.argument.weighting-rank-filter = 3
{% if facetimage_wsclean_nwavelengths > 0.0 %}
wsclean_image_full.argument.baseline-averaging    = {{ facetimage_wsclean_nwavelengths }}
{% endif %}
wsclean_image_full.argument.auto-mask             = 3
wsclean_image_full.argument.auto-threshold        = 1.0
wsclean_image_full.argument.local-rms-window      = 50
wsclean_image_full.argument.local-rms-method      = rms-with-min

# make a mapfile with the root-name of the WSClean images, length = 1
create_imagebase_map.control.kind        = plugin
create_imagebase_map.control.type        = trimMapfile
create_imagebase_map.control.mapfile_in  = wsclean_image_full.output.wsclean_image_full-image.fits.mapfile
create_imagebase_map.control.trim        = -
create_imagebase_map.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map.control.filename    = wsclean_image_full_image_rootnames.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile1.control.kind        = plugin
adjust_wsclean_mapfile1.control.type        = appendMapfile
adjust_wsclean_mapfile1.control.mapfile_in  = create_imagebase_map.output.mapfile
adjust_wsclean_mapfile1.control.append      = {{ wsclean_selfcal_facet_image_suffix }}
adjust_wsclean_mapfile1.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile1.control.filename    = final_image1.mapfile

# make a mask from the updated image, length = 1
# we use high thresholds to pick up only the brightest sources and exclude artifacts
mask5.control.type                = make_clean_mask
mask5.control.mapfile_in          = adjust_wsclean_mapfile1.output.mapfile
mask5.control.inputkey            = imagefile
mask5.control.outputkey           = maskfile
mask5.argument.flags              = [imagefile,maskfile]
mask5.argument.region_file        = {{ region_field }}
mask5.argument.threshisl          = 6
mask5.argument.threshpix          = 8
mask5.argument.rmsbox             = (80,20)
mask5.argument.adaptive_rmsbox    = True
mask5.argument.atrous_do          = False
mask5.argument.img_format         = fits
mask5.argument.vertices_file      = {{ vertices_file }}
mask5.argument.exclude_cal_region = True
mask5.argument.dilate             = 2

# check the mask6 output and modify its mapfile if no sources were found, length = 1
check_mask_high.control.kind          = plugin
check_mask_high.control.type          = checkMapfile
check_mask_high.control.mapfile_in    = mask5.output.mapfile
check_mask_high.control.mapfile_check = mask5.output.threshold_5sig.mapfile
check_mask_high.control.mapfile_dir   = input.output.mapfile_dir
check_mask_high.control.filename      = check_mask5_map.mapfile

# make a mapfile with the root-name of the final WSClean images, length = 1
create_model5_map.control.kind        = plugin
create_model5_map.control.type        = trimMapfile
create_model5_map.control.mapfile_in  = wsclean_image_full.output.wsclean_image_full-model.fits.mapfile
create_model5_map.control.trim        = -
create_model5_map.control.mapfile_dir = input.output.mapfile_dir
create_model5_map.control.filename    = final_model_rootnames.mapfile

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_model5_map.control.kind             = plugin
expand_model5_map.control.type             = expandMapfile
expand_model5_map.control.mapfile_in       = create_model5_map.output.mapfile
expand_model5_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_model5_map.control.mapfile_dir      = input.output.mapfile_dir
expand_model5_map.control.filename         = expand_model5_map.mapfile

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_mask5_map.control.kind             = plugin
expand_mask5_map.control.type             = expandMapfile
expand_mask5_map.control.mapfile_in       = mask5.output.mapfile
expand_mask5_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_mask5_map.control.mapfile_dir      = input.output.mapfile_dir
expand_mask5_map.control.filename         = expand_mask5_map.mapfile

# make high-res full-facet sky model, using mask above, len = nbands
make_high_facet_skymodel.control.type        = poly2sky
make_high_facet_skymodel.control.mapfiles_in = [create_msmulti_map.output.mapfile,expand_model5_map.output.mapfile,expand_mask5_map.output.mapfile]
make_high_facet_skymodel.control.inputkeys   = [msfile,rootname,mask]
make_high_facet_skymodel.control.outputkey   = skymodel
make_high_facet_skymodel.argument.flags      = [rootname,msfile,skymodel,mask]

# Make a medium-res image of the facet to pick up any extended emission missed in the high-
# res image

# convert the combined sky model into a sourcedb, length = nbands
make_sourcedb_high.control.type       = make_sourcedb
make_sourcedb_high.control.mapfile_in = make_new_cal_skymodel.output.mapfile
make_sourcedb_high.control.mapfile_in = make_high_facet_skymodel.output.mapfile
make_sourcedb_high.control.inputkey   = in
make_sourcedb_high.argument.format    = <
make_sourcedb_high.argument.outtype   = blob
make_sourcedb_high.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_high.control.kind           = plugin
expand_sourcedb_high.control.type           = mapfileSingleToGroup
expand_sourcedb_high.control.mapfile_in     = make_sourcedb_high.output.mapfile
expand_sourcedb_high.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_high.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_high.control.filename       = expand_sourcedb_high.mapfile

# subtract the high-resolution model, length = nfiles
# compress data and weights
subtract_high.control.type                                 = dppp
subtract_high.control.mapfiles_in                          = [prepare_imaging_data.output.mapfile,expand_sourcedb_high.output.mapfile]
subtract_high.control.inputkeys                            = [msin,sourcedb_high]
subtract_high.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
subtract_high.argument.msin.datacolumn                     = DATA
subtract_high.argument.msout.overwrite                     = True
subtract_high.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
subtract_high.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
subtract_high.argument.steps                               = [subtract,avg]
subtract_high.argument.subtract.type                       = predict
subtract_high.argument.subtract.sourcedb                   = sourcedb_high
subtract_high.argument.subtract.operation                  = subtract
subtract_high.argument.avg.type                            = squash
subtract_high.argument.avg.freqstep                        = {{ facetimage_low_freqstep }}
subtract_high.argument.avg.timestep                        = {{ facetimage_low_timestep }}
{% if use_compression %}
subtract_high.argument.msout.storagemanager                = "Dysco"
subtract_high.argument.msout.storagemanager.databitrate    = 0
subtract_high.argument.msout.storagemanager.weightbitrate  = 12
subtract_high.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
subtract_high.argument.msout.storagemanager.disttruncation = 1.5
subtract_high.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile6.control.kind        = plugin
create_compressed_mapfile6.control.type        = compressMapfile
create_compressed_mapfile6.control.mapfile_in  = subtract_high.output.mapfile
create_compressed_mapfile6.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile6.control.filename    = concat_averaged_med_input.mapfile

# Make a facet clean mask from the facet region, length = 1
premask_med.control.type                   = make_clean_mask
premask_med.control.mapfile_in             = create_compressed_mapfile6.output.mapfile
premask_med.control.inputkey               = imagefile
premask_med.control.outputkey              = maskfile
premask_med.argument.flags                 = [imagefile,maskfile]
premask_med.argument.img_format            = fits
premask_med.argument.pad_to_size           = {{ facet_med_imsize }}
premask_med.argument.skip_source_detection = True
premask_med.argument.vertices_file         = {{ vertices_file }}
premask_med.argument.reference_ra_deg      = {{ facet_ra }}
premask_med.argument.reference_dec_deg     = {{ facet_dec }}
premask_med.argument.cellsize_deg          = {{ cellsize_facet_med_deg }}
premask_med.argument.make_blank_image      = True

# image the concatenated data with the preliminary mask at med resolution, length = 1
wsclean_image_full_med.control.type                   = wsclean
wsclean_image_full_med.control.mapfiles_in            = [create_compressed_mapfile6.output.mapfile,premask_med.output.mapfile]
wsclean_image_full_med.control.inputkeys              = [msfile,fitsmask]
{% if nbands_selfcal_facet_image > 1 %}
wsclean_image_full_med.argument.flags                 = [-no-update-model-required,-fitbeam,-reorder,-joinchannels,-multiscale,-save-source-list,-local-rms,msfile]
wsclean_image_full_med.argument.channelsout           = {{ nbands_selfcal_facet_image }}
{% else %}
wsclean_image_full_med.argument.flags                 = [-no-update-model-required,-fitbeam,-reorder,-multiscale,-save-source-list,-local-rms,msfile]
{% endif %}
wsclean_image_full_med.argument.fitsmask              = fitsmask
wsclean_image_full_med.argument.size                  = {{ facet_med_imsize }} {{ facet_med_imsize }}
wsclean_image_full_med.argument.niter                 = {{ wsclean_selfcal_full_image_niter }}
wsclean_image_full_med.argument.pol                   = I
wsclean_image_full_med.argument.weight                = briggs 0.0
wsclean_image_full_med.argument.mgain                 = 0.8
wsclean_image_full_med.argument.minuv-l               = {{ facet_min_uv_lambda }}
wsclean_image_full_med.argument.taper-gaussian        = {{ cellsize_facet_med_deg*3600*3 }}arcsec
wsclean_image_full_med.argument.scale                 = {{ cellsize_facet_med_deg }}
wsclean_image_full_med.argument.mem                   = {{ max_percent_memory_per_proc_single }}
wsclean_image_full_med.argument.j                     = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image_full_med.argument.tempdir               = {{ local_dir_parent }}
{% endif %}
wsclean_image_full_med.argument.multiscale-shape      = gaussian
{% if nbands_selfcal_facet_image > 3 %}
wsclean_image_full_med.argument.fit-spectral-pol      = 3
{% elif nbands_selfcal_facet_image > 1 %}
wsclean_image_full_med.argument.fit-spectral-pol      = {{ nbands_selfcal_facet_image - 1 }}
{% endif %}
wsclean_image_full_med.argument.weighting-rank-filter = 3
{% if facetimage_medlow_wsclean_nwavelengths > 0.0 %}
wsclean_image_full_med.argument.baseline-averaging    = {{ facetimage_medlow_wsclean_nwavelengths }}
{% endif %}
wsclean_image_full_med.argument.auto-mask             = 3
wsclean_image_full_med.argument.auto-threshold        = 0.5
wsclean_image_full_med.argument.local-rms-window      = 50
wsclean_image_full_med.argument.local-rms-method      = rms-with-min

# make a mapfile with the root-name of the WSClean images, length = 1
create_imagebase_med_map.control.kind        = plugin
create_imagebase_med_map.control.type        = trimMapfile
create_imagebase_med_map.control.mapfile_in  = wsclean_image_full_med.output.wsclean_image_full_med-image.fits.mapfile
create_imagebase_med_map.control.trim        = -
create_imagebase_med_map.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_med_map.control.filename    = wsclean_image_full_med_image_rootnames.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile3.control.kind        = plugin
adjust_wsclean_mapfile3.control.type        = appendMapfile
adjust_wsclean_mapfile3.control.mapfile_in  = create_imagebase_med_map.output.mapfile
adjust_wsclean_mapfile3.control.append      = {{ wsclean_selfcal_facet_image_suffix }}
adjust_wsclean_mapfile3.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile3.control.filename    = final_image_med.mapfile

# make a mask from the updated image, length = 1
# we use high thresholds to pick up only the brightest sources and exclude artifacts
mask6.control.type                = make_clean_mask
mask6.control.mapfile_in          = adjust_wsclean_mapfile3.output.mapfile
mask6.control.inputkey            = imagefile
mask6.control.outputkey           = maskfile
mask6.argument.flags              = [imagefile,maskfile]
mask6.argument.region_file        = {{ region_field }}
mask6.argument.threshisl          = 5
mask6.argument.threshpix          = 8
mask6.argument.rmsbox             = (80,20)
mask6.argument.adaptive_rmsbox    = True
mask6.argument.atrous_do          = True
mask6.argument.img_format         = fits
mask6.argument.vertices_file      = {{ vertices_file }}
mask6.argument.exclude_cal_region = False
mask6.argument.dilate             = 2

# check the mask6 output and modify its mapfile if no sources were found, length = 1
check_mask_med.control.kind          = plugin
check_mask_med.control.type          = checkMapfile
check_mask_med.control.mapfile_in    = mask6.output.mapfile
check_mask_med.control.mapfile_check = mask6.output.threshold_5sig.mapfile
check_mask_med.control.mapfile_dir   = input.output.mapfile_dir
check_mask_med.control.filename      = check_mask6_map.mapfile

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_model6_map.control.kind             = plugin
expand_model6_map.control.type             = expandMapfile
expand_model6_map.control.mapfile_in       = create_imagebase_med_map.output.mapfile
expand_model6_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_model6_map.control.mapfile_dir      = input.output.mapfile_dir
expand_model6_map.control.filename         = expand_model6_map.mapfile

# expand the mask mapfile so that there is one entry for every band, length = nbands
expand_mask6_map.control.kind             = plugin
expand_mask6_map.control.type             = expandMapfile
expand_mask6_map.control.mapfile_in       = check_mask_med.output.mapfile
expand_mask6_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_mask6_map.control.mapfile_dir      = input.output.mapfile_dir
expand_mask6_map.control.filename         = expand_mask6_map.mapfile

# make med-res full-facet sky model, using mask above, len = nbands
make_med_facet_skymodel.control.type        = poly2sky
make_med_facet_skymodel.control.mapfiles_in = [create_msmulti_map.output.mapfile,expand_model6_map.output.mapfile,expand_mask6_map.output.mapfile]
make_med_facet_skymodel.control.inputkeys   = [msfile,rootname,mask]
make_med_facet_skymodel.control.outputkey   = skymodel
make_med_facet_skymodel.argument.flags      = [rootname,msfile,skymodel,mask,0.0,0.0]

# combine the medium- and high-res facet sky models, length = nbands
combine_facet_skymodels.control.type        = combine_skymodels
combine_facet_skymodels.control.mapfiles_in = [make_high_facet_skymodel.output.mapfile,make_med_facet_skymodel.output.mapfile]
combine_facet_skymodels.control.inputkeys   = [highresmodel,medresmodel]
combine_facet_skymodels.control.outputkey   = skymodel
combine_facet_skymodels.argument.flags      = [highresmodel,medresmodel,skymodel]

# convert the combined sky model for facet imaging into a sourcedb, length = nbands
make_sourcedb_new_facet_sources_for_facet_imaging.control.type       = make_sourcedb
make_sourcedb_new_facet_sources_for_facet_imaging.control.mapfile_in = combine_facet_skymodels.output.mapfile
make_sourcedb_new_facet_sources_for_facet_imaging.control.inputkey   = in
make_sourcedb_new_facet_sources_for_facet_imaging.argument.format    = <
make_sourcedb_new_facet_sources_for_facet_imaging.argument.outtype   = blob
make_sourcedb_new_facet_sources_for_facet_imaging.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_new_facet_sources.control.kind           = plugin
expand_sourcedb_new_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_new_facet_sources.control.mapfile_in     = make_sourcedb_new_facet_sources_for_facet_imaging.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_new_facet_sources.control.filename       = expand_sourcedb_new_facet_sources.mapfile

{% endif %}
########## end of the "is the calibrator the full facet" block

# predict the old and new models and subtract the old one from the new one, length = nfiles
# compress weights only
predict_and_difference_models.control.type                                 = dppp
{% if not is_patch %}
predict_and_difference_models.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_new_facet_sources.output.mapfile,expand_normalized_merged_parmdb_map.output.mapfile,expand_cal_sourcedb_map.output.mapfile,expand_merged_parmdb_map.output.mapfile,expand_sourcedb_all_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
predict_and_difference_models.control.inputkeys                            = [msin,facet_sourcedb,dir_dep_parmdb_normalized,cal_sourcedb,dir_dep_parmdb_unnormalized,dir_indep_sourcedb,dir_indep_parmdb]
{% else %}
predict_and_difference_models.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_cal_sourcedb_map.output.mapfile,expand_merged_parmdb_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
predict_and_difference_models.control.inputkeys                            = [msin,cal_sourcedb,dir_dep_parmdb_unnormalized,dir_indep_sourcedb,dir_indep_parmdb]
{% endif %}
predict_and_difference_models.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
predict_and_difference_models.argument.msin.datacolumn                     = DATA
predict_and_difference_models.argument.msout.overwrite                     = True
predict_and_difference_models.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
predict_and_difference_models.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
{% if not is_patch %}
predict_and_difference_models.argument.steps                               = [pred_cal,pred_facet,subtract_old]
predict_and_difference_models.argument.pred_facet.type                     = predict
predict_and_difference_models.argument.pred_facet.sourcedb                 = facet_sourcedb
predict_and_difference_models.argument.pred_facet.applycal.parmdb          = dir_dep_parmdb_normalized
predict_and_difference_models.argument.pred_facet.operation                = add
{% else %}
predict_and_difference_models.argument.steps                               = [pred_cal,subtract_old]
{% endif %}
predict_and_difference_models.argument.pred_cal.type                       = predict
predict_and_difference_models.argument.pred_cal.sourcedb                   = cal_sourcedb
predict_and_difference_models.argument.pred_cal.applycal.parmdb            = dir_dep_parmdb_unnormalized
predict_and_difference_models.argument.pred_cal.operation                  = replace
predict_and_difference_models.argument.subtract_old.type                   = predict
predict_and_difference_models.argument.subtract_old.sourcedb               = dir_indep_sourcedb
predict_and_difference_models.argument.subtract_old.applycal.parmdb        = dir_indep_parmdb
predict_and_difference_models.argument.subtract_old.operation              = subtract
{% if use_compression %}
predict_and_difference_models.argument.msout.storagemanager                = "Dysco"
predict_and_difference_models.argument.msout.storagemanager.databitrate    = 0
predict_and_difference_models.argument.msout.storagemanager.weightbitrate  = 12
predict_and_difference_models.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
predict_and_difference_models.argument.msout.storagemanager.disttruncation = 1.5
predict_and_difference_models.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

#
# Verify the quality of selfcal on the middle band
#

# make a map with original facet data of only the central frequency band, length = ntimes
create_middle_band_mapfile1.control.kind        = plugin
create_middle_band_mapfile1.control.type        = selectMiddleFreq
create_middle_band_mapfile1.control.mapfile_in  = create_ms_map.output.mapfile
create_middle_band_mapfile1.control.mapfile_dir = input.output.mapfile_dir
create_middle_band_mapfile1.control.filename    = single_band_orig.mapfile

# make a map with new facet data of only the central frequency band, length = ntimes
create_middle_band_mapfile2.control.kind        = plugin
create_middle_band_mapfile2.control.type        = selectMiddleFreq
create_middle_band_mapfile2.control.mapfile_in  = predict_and_difference_models.output.mapfile
create_middle_band_mapfile2.control.mapfile_dir = input.output.mapfile_dir
create_middle_band_mapfile2.control.filename    = single_band_new.mapfile

# subtract new facet data from original data, length = ntimes
subtract_single.control.type        = add_subtract_columns
subtract_single.control.mapfiles_in = [create_middle_band_mapfile2.output.mapfile,create_middle_band_mapfile1.output.mapfile]
subtract_single.control.inputkeys   = [file1,file2]
subtract_single.argument.flags      = [file1,file2,DATA,{{ subtracted_data_colname }},MODEL_DATA,subtract21]

# average old empty data, length = ntimes
average_pre.control.type                                 = dppp
average_pre.control.mapfile_in                           = create_middle_band_mapfile1.output.mapfile
average_pre.control.inputkey                             = msin
average_pre.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
average_pre.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
average_pre.argument.msout.overwrite                     = True
average_pre.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average_pre.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average_pre.argument.steps                               = [uv,avg]
average_pre.argument.uv.type                             = uvwflagger
average_pre.argument.uv.uvmmax                           = 2500.0
average_pre.argument.avg.type                            = squash
average_pre.argument.avg.freqstep                        = {{ verify_freqstep }}
average_pre.argument.avg.timestep                        = {{ verify_timestep }}
{% if use_compression %}
average_pre.argument.msout.storagemanager                = "Dysco"
average_pre.argument.msout.storagemanager.databitrate    = 16
average_pre.argument.msout.storagemanager.weightbitrate  = 12
average_pre.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average_pre.argument.msout.storagemanager.disttruncation = 1.5
average_pre.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# average "old minus new" facet data (= new empty data), length = ntimes
average_post.control.type                                 = dppp
average_post.control.mapfile_in                           = create_middle_band_mapfile2.output.mapfile
average_post.control.inputkey                             = msin
average_post.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
average_post.argument.msin.datacolumn                     = MODEL_DATA
average_post.argument.msout.overwrite                     = True
average_post.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average_post.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average_post.argument.steps                               = [uv,avg]
average_post.argument.uv.type                             = uvwflagger
average_post.argument.uv.uvmmax                           = 2500.0
average_post.argument.avg.type                            = squash
average_post.argument.avg.freqstep                        = {{ verify_freqstep }}
average_post.argument.avg.timestep                        = {{ verify_timestep }}
{% if use_compression %}
average_post.argument.msout.storagemanager                = "Dysco"
average_post.argument.msout.storagemanager.databitrate    = 16
average_post.argument.msout.storagemanager.weightbitrate  = 12
average_post.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average_post.argument.msout.storagemanager.disttruncation = 1.5
average_post.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile of old empty data, length = 1
average_pre_compressed_map.control.kind        = plugin
average_pre_compressed_map.control.type        = compressMapfile
average_pre_compressed_map.control.mapfile_in  = average_pre.output.mapfile
average_pre_compressed_map.control.mapfile_dir = input.output.mapfile_dir
average_pre_compressed_map.control.filename    = average_pre_compressed.mapfile

# image the old empty data, length = 1
wsclean_pre.control.type         = wsclean
wsclean_pre.control.mapfile_in   = average_pre_compressed_map.output.mapfile
wsclean_pre.control.inputkey     = msfiles
wsclean_pre.argument.flags       = [-no-update-model-required,msfiles]
wsclean_pre.argument.size        = 2048 2048
wsclean_pre.argument.niter       = 10
wsclean_pre.argument.threshold   = 0.0
wsclean_pre.argument.pol         = I
wsclean_pre.argument.weight      = briggs -0.5
wsclean_pre.argument.mgain       = 0.8
wsclean_pre.argument.gain        = 0.1
wsclean_pre.argument.minuv-l     = {{ facet_min_uv_lambda }}
wsclean_pre.argument.maxuv-l     = 2500
wsclean_pre.argument.scale       = 0.00833
wsclean_pre.argument.mem         = {{ max_percent_memory_per_proc_single }}
wsclean_pre.argument.j           = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_pre.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

# make compressed mapfile of new empty data, length = 1
average_post_compressed_map.control.kind        = plugin
average_post_compressed_map.control.type        = compressMapfile
average_post_compressed_map.control.mapfile_in  = average_post.output.mapfile
average_post_compressed_map.control.mapfile_dir = input.output.mapfile_dir
average_post_compressed_map.control.filename    = average_post_compressed.mapfile

# image the new empty data, length = 1
wsclean_post.control.type         = wsclean
wsclean_post.control.mapfile_in   = average_post_compressed_map.output.mapfile
wsclean_post.control.inputkey     = msfiles
wsclean_post.argument.flags       = [-no-update-model-required,msfiles]
wsclean_post.argument.size        = 2048 2048
wsclean_post.argument.niter       = 10
wsclean_post.argument.threshold   = 0.0
wsclean_post.argument.pol         = I
wsclean_post.argument.weight      = briggs -0.5
wsclean_post.argument.mgain       = 0.8
wsclean_post.argument.gain        = 0.1
wsclean_post.argument.minuv-l     = {{ facet_min_uv_lambda }}
wsclean_post.argument.maxuv-l     = 2500
wsclean_post.argument.scale       = 0.00833
wsclean_post.argument.mem         = {{ max_percent_memory_per_proc_single }}
wsclean_post.argument.j           = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_post.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

# do a "verify_subtract" on the two "empty" images, length = 1
verify_subtract.control.type        = verify_subtract
verify_subtract.control.mapfiles_in = [wsclean_pre.output.wsclean_pre-image.fits.mapfile,wsclean_post.output.wsclean_post-image.fits.mapfile]
verify_subtract.control.inputkeys   = [image_pre,image_post]
verify_subtract.argument.flags      = [image_pre,image_post,0.75]
