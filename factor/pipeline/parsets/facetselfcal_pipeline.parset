pipeline.steps = [update_mapfile_hosts, create_ms_map, create_msmulti_map, create_parmdb_map, create_full_skymodels_map, make_facet_skymodels_cal, make_sourcedb_cal_facet_sources, expand_sourcedb_cal_facet_sources, {% if preapply_phase_cal %} expand_preapply_parmdb_map, {% endif %} shift_cal, {% if preapply_phase_cal %} shift_cal_dir_indep, {% endif %} create_compressed_mapfile_data, sort_into_Groups, sort_into_Groups_maps, concat_data, {% if pre_average %} regroup_shift_cal, regroup_parmdb, calc_bl, create_bl_mapfile1, pre_average, make_blavg_data_mapfile, concat_blavg_data, create_bl_mapfile2, pre_average_freq, {% endif %} {% if selfcal_local_dir is not none %} {% if not pre_average %} make_concat_data_sync_mapfile, adjust_concat_data_hosts, sync_concat_data_to_local, {% else %} make_concat_blavg_data_sync_mapfile, adjust_concat_blavg_data_hosts, adjust_concat_data_hosts, sync_concat_blavg_data_to_local, {% endif %} {% endif %} concat_data_compressed_mapfile, {% block selfcal_steps %} {% if not preapply_phase_cal %} average0, {% endif %} create_compressed_mapfile0, sort_average0_into_Groups, sort_average0_into_Groups_maps, concat_average0_data, create_compressed_mapfile01, premask_selfcal, wsclean_image02, create_imagebase_map02, pad_selfcal_model0_images, regroup_concat_data_map, create_expanded_model0_mapfile, expand_selfcal_model_size_map, wsclean_ft0, make_fast_phase_parmdb_map, {% if peel_skymodel is not none %} create_peel_skymodel_map, make_peel_sourcedb, expand_peel_sourcedb_map, {% endif %} remove_parmdbs1, solve_phaseonly1, {% if selfcal_local_dir is not none %} make_apply_mapfile, {% endif %} apply_phaseonly1, create_compressed_mapfile1, wsclean_image12, create_imagebase_map12, create_expanded_model1_mapfile, pad_selfcal_model1_images, wsclean_ft1, remove_parmdbs2, solve_phaseonly2, apply_phaseonly2, create_compressed_mapfile2, wsclean_image22, create_imagebase_map22, create_expanded_model2_mapfile, pad_selfcal_model2_images, wsclean_ft2, remove_parmdbs11, solve_ampphase11, apply_ampphase11, make_slow_gain_parmdb_map, remove_parmdbs12, solve_ampphase12, merge_amp_parmdbs1, smooth_amp1, expand_smoothed_amp1_parmdb_map, apply_amp1, create_compressed_mapfile3, wsclean_image32, loop_ampcal, {% endblock selfcal_steps %} {% if selfcal_local_dir is not none %} {% if not pre_average %} remove_concat_data, {% else %} remove_concat_blavg_data, {% endif %} {% endif %} merge_selfcal_parmdbs, convert_merged_selfcal_parmdbs, {% if create_preapply_parmdb %} create_preapply_parmdb, {% endif %} make_selfcal_plots, create_selfcal_images_mapfile, make_selfcal_images, expand_merged_parmdb_map, create_model4_map, expand_model4_map, blank_mask, expand_mask4_map, make_new_cal_skymodel, {% if not is_patch or wsclean_selfcal_multiscale %} make_facet_skymodels_all, make_sourcedb_all_facet_sources, expand_sourcedb_all_facet_sources, prepare_imaging_data, {% if not is_patch %} create_compressed_mapfile5, premask, wsclean_image_full, create_imagebase_map, adjust_wsclean_mapfile1, mask5, check_mask_high, create_model5_map, expand_model5_map, expand_mask5_map, make_high_facet_skymodel, combine_skymodels_high, {% endif %} make_sourcedb_high, expand_sourcedb_high, subtract_high, create_compressed_mapfile6, premask_med, wsclean_image_full_med, create_imagebase_med_map, adjust_wsclean_mapfile3, mask6, check_mask_med, expand_model6_map, expand_mask6_map, make_med_facet_skymodel, combine_facet_skymodels, make_sourcedb_new_facet_sources, expand_sourcedb_new_facet_sources, {% else %} make_sourcedb_new_facet_sources, expand_sourcedb_new_facet_sources, {% endif %} predict_and_difference_models, create_middle_band_mapfile1, create_middle_band_mapfile2, subtract_single, average_pre, average_post, average_pre_compressed_map, wsclean_pre, average_post_compressed_map, wsclean_post, verify_subtract]

pipeline.pluginpath = {{ pipeline_dir }}/plugins

update_mapfile_hosts.control.kind        = plugin
update_mapfile_hosts.control.type        = updateHosts
update_mapfile_hosts.control.mapfile_dir = input.output.mapfile_dir
update_mapfile_hosts.control.hosts       = {{ hosts }}

# create a mapfile with all single MSs from supplied list, length = nfiles
create_ms_map.control.kind        = plugin
create_ms_map.control.type        = addListMapfile
create_ms_map.control.hosts       = {{ hosts }}
create_ms_map.control.files       = {{ ms_files_single }}
create_ms_map.control.mapfile_dir = input.output.mapfile_dir
create_ms_map.control.filename    = input_files_single.mapfile

# create a multi-mapfile with the groups of MSs from supplied list, length = nbands
create_msmulti_map.control.kind        = plugin
create_msmulti_map.control.type        = addListMultiMapfile
create_msmulti_map.control.hosts       = {{ hosts }}
create_msmulti_map.control.files       = {{ ms_files_grouped }}
create_msmulti_map.control.mapfile_dir = input.output.mapfile_dir
create_msmulti_map.control.filename    = input_files_grouped.mapfile

# create a mapfile with the direction-independent parmDBs from supplied list, length = nfiles
create_parmdb_map.control.kind        = plugin
create_parmdb_map.control.type        = addListMapfile
create_parmdb_map.control.hosts       = {{ hosts }}
create_parmdb_map.control.files       = {{ dir_indep_parmDBs }}
create_parmdb_map.control.mapfile_dir = input.output.mapfile_dir
create_parmdb_map.control.filename    = dir_indep_instrument_parmdbs.mapfile

# create a mapfile with the current skymodels from supplied list, length = nbands
create_full_skymodels_map.control.kind        = plugin
create_full_skymodels_map.control.type        = addListMapfile
create_full_skymodels_map.control.hosts       = {{ hosts }}
create_full_skymodels_map.control.files       = {{ skymodels }}
create_full_skymodels_map.control.mapfile_dir = input.output.mapfile_dir
create_full_skymodels_map.control.filename    = full_skymodels.mapfile

# extract the skymodel for the calibrator of this facet from global skymodel, length = nbands
make_facet_skymodels_cal.control.type       = make_facet_skymodel
make_facet_skymodels_cal.control.mapfile_in = create_full_skymodels_map.output.mapfile
make_facet_skymodels_cal.control.inputkey   = fullmodelfile
make_facet_skymodels_cal.control.outputkey  = outfile
make_facet_skymodels_cal.argument.flags     = [fullmodelfile,outfile,{{ vertices_file }}]
make_facet_skymodels_cal.argument.cal_only  = True

# convert the facet skymodel into a sourcedb, length = nbands
make_sourcedb_cal_facet_sources.control.type       = make_sourcedb
make_sourcedb_cal_facet_sources.control.mapfile_in = make_facet_skymodels_cal.output.mapfile
make_sourcedb_cal_facet_sources.control.inputkey   = in
make_sourcedb_cal_facet_sources.argument.format    = <
make_sourcedb_cal_facet_sources.argument.outtype   = blob
make_sourcedb_cal_facet_sources.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_cal_facet_sources.control.kind           = plugin
expand_sourcedb_cal_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_cal_facet_sources.control.mapfile_in     = make_sourcedb_cal_facet_sources.output.mapfile
expand_sourcedb_cal_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_cal_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_cal_facet_sources.control.filename       = expand_sourcedb_cal_facet_sources.mapfile

{% if preapply_phase_cal %}
# expand mapfile of the dir-dependent parmDB to all files, length = nfiles
expand_preapply_parmdb_map.control.kind             = plugin
expand_preapply_parmdb_map.control.type             = expandMapfile
expand_preapply_parmdb_map.control.mapfile_in       = {{ preapply_parmdb_mapfile }}
expand_preapply_parmdb_map.control.mapfile_to_match = create_ms_map.output.mapfile
expand_preapply_parmdb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_preapply_parmdb_map.control.filename         = expand_preapply_parmdbs.mapfile
{% endif %}

# shift data to calibrator position, predict and add calibrator sources, and average in frequency, length = nfiles
# Compress both data and weights
shift_cal.control.type                                 = dppp
{% if preapply_phase_cal %}
shift_cal.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,create_parmdb_map.output.mapfile,expand_preapply_parmdb_map.output.mapfile]
shift_cal.control.inputkeys                            = [msin,sourcedb,dir_indep_parmdb,preapply_parmdb]
{% else %}
shift_cal.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
shift_cal.control.inputkeys                            = [msin,sourcedb,dir_indep_parmdb]
{% endif %}
shift_cal.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
shift_cal.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
shift_cal.argument.msout.overwrite                     = True
shift_cal.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
shift_cal.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
{% if preapply_phase_cal %}
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
shift_cal.argument.steps                               = [shift,add,flag,correct,avg]
{% else %}
shift_cal.argument.steps                               = [shift,add,correct,avg]
{% endif %}
shift_cal.argument.correct.type                        = applycal
shift_cal.argument.correct.parmdb                      = preapply_parmdb
shift_cal.argument.correct.invert                      = True
{% else %}
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
shift_cal.argument.steps                               = [shift,add,flag,avg]
{% else %}
shift_cal.argument.steps                               = [shift,add,avg]
{% endif %}
{% endif %}
shift_cal.argument.shift.type                          = phaseshifter
shift_cal.argument.shift.phasecenter                   = [{{ ra }}deg, {{ dec }}deg]
shift_cal.argument.add.type                            = predict
shift_cal.argument.add.sourcedb                        = sourcedb
shift_cal.argument.add.operation                       = add
shift_cal.argument.add.applycal.parmdb                 = dir_indep_parmdb
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
shift_cal.argument.flag.type                           = preflagger
shift_cal.argument.flag.expr                           = {{ flag_expr }}
{% endif %}
{% if flag_abstime is not none %}
shift_cal.argument.flag.flag_abstime.abstime           = {{ flag_abstime }}
{% endif %}
{% if flag_baseline is not none %}
shift_cal.argument.flag.flag_baseline.baseline         = {{ flag_baseline }}
{% endif %}
{% if flag_freqrange is not none %}
shift_cal.argument.flag.flag_freqrange.freqrange       = {{ flag_freqrange }}
{% endif %}
shift_cal.argument.avg.type                            = squash
shift_cal.argument.avg.freqstep                        = {{ facetselfcal_freqstep }}
shift_cal.argument.avg.timestep                        = 1
{% if use_compression %}
shift_cal.argument.msout.storagemanager                = "Dysco"
shift_cal.argument.msout.storagemanager.databitrate    = 16
shift_cal.argument.msout.storagemanager.weightbitrate  = 12
shift_cal.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
shift_cal.argument.msout.storagemanager.disttruncation = 1.5
shift_cal.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

{% if preapply_phase_cal %}
# If we preapplied solutions above, we also need a dir-indep corrected   // length = nfiles
# version of the shift_cal data for the initial selfcal image
# Compress both data and weights
shift_cal_dir_indep.control.type                                 = dppp
shift_cal_dir_indep.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
shift_cal_dir_indep.control.inputkeys                            = [msin,sourcedb,dir_indep_parmdb]
shift_cal_dir_indep.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
shift_cal_dir_indep.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
shift_cal_dir_indep.argument.msout.overwrite                     = True
shift_cal_dir_indep.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
shift_cal_dir_indep.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
shift_cal_dir_indep.argument.steps                               = [shift,add,flag,correct,avg]
{% else %}
shift_cal_dir_indep.argument.steps                               = [shift,add,correct,avg]
{% endif %}
shift_cal_dir_indep.argument.shift.type                          = phaseshifter
shift_cal_dir_indep.argument.shift.phasecenter                   = [{{ ra }}deg, {{ dec }}deg]
shift_cal_dir_indep.argument.add.type                            = predict
shift_cal_dir_indep.argument.add.sourcedb                        = sourcedb
shift_cal_dir_indep.argument.add.operation                       = add
shift_cal_dir_indep.argument.add.applycal.parmdb                 = dir_indep_parmdb
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
shift_cal_dir_indep.argument.flag.type                           = preflagger
shift_cal_dir_indep.argument.flag.expr                           = {{ flag_expr }}
{% endif %}
{% if flag_abstime is not none %}
shift_cal_dir_indep.argument.flag.flag_abstime.abstime           = {{ flag_abstime }}
{% endif %}
{% if flag_baseline is not none %}
shift_cal_dir_indep.argument.flag.flag_baseline.baseline         = {{ flag_baseline }}
{% endif %}
{% if flag_freqrange is not none %}
shift_cal_dir_indep.argument.flag.flag_freqrange.freqrange       = {{ flag_freqrange }}
{% endif %}
shift_cal_dir_indep.argument.correct.type                        = applycal
shift_cal_dir_indep.argument.correct.parmdb                      = dir_indep_parmdb
shift_cal_dir_indep.argument.correct.correction                  = gain
shift_cal_dir_indep.argument.correct.invert                      = True
shift_cal_dir_indep.argument.avg.type                            = squash
shift_cal_dir_indep.argument.avg.freqstep                        = {{ facetselfcal_freqstep }}
shift_cal_dir_indep.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
shift_cal_dir_indep.argument.msout.storagemanager                = "Dysco"
shift_cal_dir_indep.argument.msout.storagemanager.databitrate    = 16
shift_cal_dir_indep.argument.msout.storagemanager.weightbitrate  = 12
shift_cal_dir_indep.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
shift_cal_dir_indep.argument.msout.storagemanager.disttruncation = 1.5
shift_cal_dir_indep.argument.msout.storagemanager.normalization  = "AF"
{% endif %}
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile_data.control.kind        = plugin
create_compressed_mapfile_data.control.type        = compressMapfile
create_compressed_mapfile_data.control.mapfile_in  = shift_cal.output.mapfile
create_compressed_mapfile_data.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile_data.control.filename    = concat_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes * num_cal_blocks
# we make dummy data here so that there will always be MS files for wsclean
# predict, even if a cal block is completely flagged (which otherwise would get
# skipped and cause problems with predict)
sort_into_Groups.control.type                 = sort_times_into_freqGroups
sort_into_Groups.argument.flags               = [create_compressed_mapfile_data.output.mapfile]
sort_into_Groups.argument.filename            = sorted_groups.mapfile
sort_into_Groups.argument.mapfile_dir         = input.output.mapfile_dir
sort_into_Groups.argument.hosts               = {{ hosts }}
sort_into_Groups.argument.stepname            = sort_into_Groups
sort_into_Groups.argument.enforce_numSB       = False
{% if num_cal_blocks > 1 %}
sort_into_Groups.argument.numSB               = {{ num_bands_per_cal_block }}
{% endif %}
sort_into_Groups.argument.nband_pad           = {{ nband_pad_selfcal }}
sort_into_Groups.argument.make_dummy_files    = True
sort_into_Groups.argument.skip_flagged_groups = False

# convert the output of sort_into_Groups into usable mapfiles, len = 1 / (ntimes * num_cal_blocks)
sort_into_Groups_maps.control.kind             = plugin
sort_into_Groups_maps.control.type             = mapfilenamesFromMapfiles
sort_into_Groups_maps.control.mapfile_groupmap = sort_into_Groups.output.groupmapfile.mapfile
sort_into_Groups_maps.control.mapfile_filesmap = sort_into_Groups.output.mapfile.mapfile

# concat data in frequency, length = ntimes * num_cal_blocks
# Note, this step is done because DPPP cannot handle datasets with multiple spectral
# windows, as occurs when MSs at several frequencies are virtually concatenated
# Compress both data and weights
concat_data.control.type                                 = dppp
concat_data.control.mapfile_out                          = sort_into_Groups_maps.output.groupmap
concat_data.control.mapfile_in                           = sort_into_Groups_maps.output.filesmap
concat_data.control.inputkey                             = msin
concat_data.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
concat_data.argument.msin.datacolumn                     = DATA
concat_data.argument.msin.missingdata                    = True
concat_data.argument.msin.orderms                        = False
concat_data.argument.msout.overwrite                     = True
concat_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
concat_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
concat_data.argument.steps                               = []
{% if use_compression %}
concat_data.argument.msout.storagemanager                = "Dysco"
concat_data.argument.msout.storagemanager.databitrate    = 16
concat_data.argument.msout.storagemanager.weightbitrate  = 12
concat_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
concat_data.argument.msout.storagemanager.disttruncation = 1.5
concat_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

{% if pre_average %}
# re-group shift_cal mapfile to have one group per band, length = nbands
regroup_shift_cal.control.kind           = plugin
regroup_shift_cal.control.type           = reGroupMapfile
regroup_shift_cal.control.mapfile_in     = shift_cal.output.mapfile
regroup_shift_cal.control.mapfile_groups = create_msmulti_map.output.mapfile
regroup_shift_cal.control.mapfile_dir    = input.output.mapfile_dir
regroup_shift_cal.control.filename       = regroup_shift_cal.mapfile

# re-group dir-independent parmdb mapfile to have one group per band, length = nbands
regroup_parmdb.control.kind           = plugin
regroup_parmdb.control.type           = reGroupMapfile
regroup_parmdb.control.mapfile_in     = create_parmdb_map.output.mapfile
regroup_parmdb.control.mapfile_groups = create_msmulti_map.output.mapfile
regroup_parmdb.control.check_basename = False
regroup_parmdb.control.mapfile_dir    = input.output.mapfile_dir
regroup_parmdb.control.filename       = re_grouped_parmdb.mapfile

# calculate baseline lengths, length = 1
calc_bl.control.type        = calculate_bl_lengths
calc_bl.control.mapfile_in  = create_compressed_mapfile_data.output.mapfile
calc_bl.control.inputkey    = datafiles
calc_bl.control.outputkey   = outfile
calc_bl.argument.flags      = [datafiles,outfile]

# expand the baseline lengths mapfile, length = nbands
create_bl_mapfile1.control.kind             = plugin
create_bl_mapfile1.control.type             = expandMapfile
create_bl_mapfile1.control.mapfile_in       = calc_bl.output.mapfile
create_bl_mapfile1.control.mapfile_to_match = regroup_shift_cal.output.mapfile
create_bl_mapfile1.control.mapfile_dir      = input.output.mapfile_dir
create_bl_mapfile1.control.filename         = expand_bl.mapfile

# do the baseline-dependent preaveraging, length = nbands
# This step makes new columns named BLAVG_DATA and BLAVG_WEIGHT_SPECTRUM
pre_average.control.type        = pre_average
pre_average.control.mapfiles_in = [regroup_shift_cal.output.mapfile,regroup_parmdb.output.mapfile,create_bl_mapfile1.output.mapfile]
pre_average.control.inputkeys   = [datafiles,parmdbs,blengths]
pre_average.argument.flags      = [datafiles,parmdbs,DATA,DATA,WEIGHT_SPECTRUM,{{ target_rms_rad }},blengths]

# make mapfile for concatenated preaveraged data, length = ntimes * num_cal_blocks
make_blavg_data_mapfile.control.kind               = plugin
make_blavg_data_mapfile.control.type               = createMapfile
make_blavg_data_mapfile.control.method             = add_suffix_to_file
make_blavg_data_mapfile.control.mapfile_in         = sort_into_Groups_maps.output.groupmap
make_blavg_data_mapfile.control.add_suffix_to_file = "_blavg.ms"
make_blavg_data_mapfile.control.mapfile_dir        = input.output.mapfile_dir
make_blavg_data_mapfile.control.filename           = make_blavg_data.mapfile

# Concat the preaveraged data (and weights), length = ntimes * num_cal_blocks
# Compress both data and weights
concat_blavg_data.control.type                                 = dppp
concat_blavg_data.control.mapfile_out                          = make_blavg_data_mapfile.output.mapfile
concat_blavg_data.control.mapfile_in                           = sort_into_Groups_maps.output.filesmap
concat_blavg_data.control.inputkey                             = msin
concat_blavg_data.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
concat_blavg_data.argument.msin.datacolumn                     = DATA
concat_blavg_data.argument.msin.missingdata                    = True
concat_blavg_data.argument.msin.orderms                        = False
concat_blavg_data.argument.msout.overwrite                     = True
concat_blavg_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
concat_blavg_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
concat_blavg_data.argument.steps                               = []
{% if use_compression %}
concat_blavg_data.argument.msout.storagemanager                = "Dysco"
concat_blavg_data.argument.msout.storagemanager.databitrate    = 16
concat_blavg_data.argument.msout.storagemanager.weightbitrate  = 12
concat_blavg_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
concat_blavg_data.argument.msout.storagemanager.disttruncation = 1.5
concat_blavg_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# expand the baseline lengths mapfile, length = ntimes * num_cal_blocks
create_bl_mapfile2.control.kind             = plugin
create_bl_mapfile2.control.type             = expandMapfile
create_bl_mapfile2.control.mapfile_in       = calc_bl.output.mapfile
create_bl_mapfile2.control.mapfile_to_match = make_blavg_data_mapfile.output.mapfile
create_bl_mapfile2.control.mapfile_dir      = input.output.mapfile_dir
create_bl_mapfile2.control.filename         = expand_bl.mapfile

# preaverage in frequency, length = ntimes * num_cal_blocks
# this step overwrites the DATA and WEIGHT_SPECTRUM columns
pre_average_freq.control.type        = pre_average_freq
pre_average_freq.control.mapfiles_in = [concat_blavg_data.output.mapfile,create_bl_mapfile2.output.mapfile]
pre_average_freq.control.inputkeys   = [datafile,blengths]
pre_average_freq.argument.flags      = [datafile,DATA,DATA,WEIGHT_SPECTRUM,blengths,{{ cal_radius_deg }}]

{% endif %}

{% if selfcal_local_dir is not none %}
{% if not pre_average %}
# make a mapfile for syncing of concat_data to selfcal_local_dir, len = ntimes * num_cal_blocks
make_concat_data_sync_mapfile.control.kind            = plugin
make_concat_data_sync_mapfile.control.type            = changeDirectory
make_concat_data_sync_mapfile.control.mapfile_in      = concat_data.output.mapfile
make_concat_data_sync_mapfile.control.new_dir         = {{ selfcal_local_dir }}
make_concat_data_sync_mapfile.control.mapfile_dir     = input.output.mapfile_dir
make_concat_data_sync_mapfile.control.filename        = concat_data_local.mapfile
make_concat_data_sync_mapfile.control.nitems_per_host = {{ num_cal_blocks }}

# adjust the concat_data hosts to match the ones for syncing, len = ntimes * num_cal_blocks
# this is needed so that the mapfiles used in sync_files step will validate
adjust_concat_data_hosts.control.kind             = plugin
adjust_concat_data_hosts.control.type             = matchHosts
adjust_concat_data_hosts.control.mapfile_in       = concat_data.output.mapfile
adjust_concat_data_hosts.control.mapfile_to_match = make_concat_data_sync_mapfile.output.mapfile

# copy the output of concat_data to selfcal_local_dir, len = ntimes * num_cal_blocks
sync_concat_data_to_local.control.type        = sync_files
sync_concat_data_to_local.control.mapfile_in  = concat_data.output.mapfile
sync_concat_data_to_local.control.mapfile_out = make_concat_data_sync_mapfile.output.mapfile
sync_concat_data_to_local.control.inputkey    = msin
sync_concat_data_to_local.control.outputkey   = msout
sync_concat_data_to_local.argument.flags      = [msin,msout]

{% else %}
# make a mapfile for syncing of concat_blavg_data to selfcal_local_dir, len = ntimes * num_cal_blocks
make_concat_blavg_data_sync_mapfile.control.kind            = plugin
make_concat_blavg_data_sync_mapfile.control.type            = changeDirectory
make_concat_blavg_data_sync_mapfile.control.mapfile_in      = concat_blavg_data.output.mapfile
make_concat_blavg_data_sync_mapfile.control.new_dir         = {{ selfcal_local_dir }}
make_concat_blavg_data_sync_mapfile.control.mapfile_dir     = input.output.mapfile_dir
make_concat_blavg_data_sync_mapfile.control.filename        = concat_blavg_data_local.mapfile
make_concat_blavg_data_sync_mapfile.control.nitems_per_host = {{ num_cal_blocks }}

# adjust the concat_blavg_data hosts to match the ones for syncing, len = ntimes * num_cal_blocks
# this is needed so that the mapfiles used in sync_files step will validate
adjust_concat_blavg_data_hosts.control.kind             = plugin
adjust_concat_blavg_data_hosts.control.type             = matchHosts
adjust_concat_blavg_data_hosts.control.mapfile_in       = concat_blavg_data.output.mapfile
adjust_concat_blavg_data_hosts.control.mapfile_to_match = make_concat_blavg_data_sync_mapfile.output.mapfile

# adjust the concat_data hosts to match the ones for syncing, len = ntimes * num_cal_blocks
# this is needed so that the mapfiles used in the apply steps will validate
adjust_concat_data_hosts.control.kind             = plugin
adjust_concat_data_hosts.control.type             = matchHosts
adjust_concat_data_hosts.control.mapfile_in       = concat_data.output.mapfile
adjust_concat_data_hosts.control.mapfile_to_match = make_concat_blavg_data_sync_mapfile.output.mapfile

# copy the output of concat_blavg_data to selfcal_local_dir, len = ntimes * num_cal_blocks
sync_concat_blavg_data_to_local.control.type        = sync_files
sync_concat_blavg_data_to_local.control.mapfile_in  = concat_blavg_data.output.mapfile
sync_concat_blavg_data_to_local.control.mapfile_out = make_concat_blavg_data_sync_mapfile.output.mapfile
sync_concat_blavg_data_to_local.control.inputkey    = msin
sync_concat_blavg_data_to_local.control.outputkey   = msout
sync_concat_blavg_data_to_local.argument.flags      = [msin,msout]
{% endif %}
{% endif %}

# make compressed mapfile for (non-local) concatenated data MSs, length = 1
concat_data_compressed_mapfile.control.kind        = plugin
concat_data_compressed_mapfile.control.type        = compressMapfile
concat_data_compressed_mapfile.control.mapfile_in  = concat_data.output.mapfile
concat_data_compressed_mapfile.control.mapfile_dir = input.output.mapfile_dir
concat_data_compressed_mapfile.control.filename    = concat_chunks_input.mapfile

{% block selfcal_parameters %}
########## start of first round of selfcal

# apply dir-independent calibration and average, length = nfiles
# this step must be done band-by-band, as each band has its own parmdb.
# if we preapply solutions, we don't need to do this step as we already have
# averaged MSs from the shift_cal_dir_indep step
# Compress both data and weights
{% if not preapply_phase_cal %}
average0.control.type                                 = dppp
average0.control.mapfiles_in                          = [shift_cal.output.mapfile,create_parmdb_map.output.mapfile]
average0.control.inputkeys                            = [msin,parmdb]
average0.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
average0.argument.msin.datacolumn                     = DATA
average0.argument.msout.overwrite                     = True
average0.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average0.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average0.argument.steps                               = [correct,avg]
average0.argument.correct.type                        = applycal
average0.argument.correct.parmdb                      = parmdb
average0.argument.correct.correction                  = gain
average0.argument.correct.invert                      = True
average0.argument.avg.type                            = squash
average0.argument.avg.freqstep                        = 1
average0.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
average0.argument.msout.storagemanager                = "Dysco"
average0.argument.msout.storagemanager.databitrate    = 16
average0.argument.msout.storagemanager.weightbitrate  = 12
average0.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average0.argument.msout.storagemanager.disttruncation = 1.5
average0.argument.msout.storagemanager.normalization  = "AF"
{% endif %}
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile0.control.kind        = plugin
create_compressed_mapfile0.control.type        = compressMapfile
{% if preapply_phase_cal %}
create_compressed_mapfile0.control.mapfile_in  = shift_cal_dir_indep.output.mapfile
{% else %}
create_compressed_mapfile0.control.mapfile_in  = average0.output.mapfile
{% endif %}
create_compressed_mapfile0.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile0.control.filename    = concat_average0_input.mapfile

# sort compressed mapfile so that there is one group per timestamp, length = ntimes
sort_average0_into_Groups.control.type           = sort_times_into_freqGroups
sort_average0_into_Groups.argument.flags         = [create_compressed_mapfile0.output.mapfile]
sort_average0_into_Groups.argument.filename      = sorted_average0_groups.mapfile
sort_average0_into_Groups.argument.mapfile_dir   = input.output.mapfile_dir
sort_average0_into_Groups.argument.hosts         = {{ hosts }}
sort_average0_into_Groups.argument.stepname      = sort_average0_into_Groups
sort_average0_into_Groups.argument.enforce_numSB = False
sort_average0_into_Groups.argument.nband_pad     = {{ nband_pad_selfcal }}

# convert the output of sort_average0_into_Groups into usable mapfiles, len = 1 / ntimes
sort_average0_into_Groups_maps.control.kind             = plugin
sort_average0_into_Groups_maps.control.type             = mapfilenamesFromMapfiles
sort_average0_into_Groups_maps.control.mapfile_groupmap = sort_average0_into_Groups.output.groupmapfile.mapfile
sort_average0_into_Groups_maps.control.mapfile_filesmap = sort_average0_into_Groups.output.mapfile.mapfile

# concat averaged data in frequency, length = ntimes
# Note, this step is done to ensure that we get WSClean channel images that match
# the datasets used for selfcal so that predict will work properly
# Compress both data and weights
concat_average0_data.control.type                                 = dppp
concat_average0_data.control.mapfile_out                          = sort_average0_into_Groups_maps.output.groupmap
concat_average0_data.control.mapfile_in                           = sort_average0_into_Groups_maps.output.filesmap
concat_average0_data.control.inputkey                             = msin
concat_average0_data.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
concat_average0_data.argument.msin.datacolumn                     = DATA
concat_average0_data.argument.msin.missingdata                    = True
concat_average0_data.argument.msin.orderms                        = False
concat_average0_data.argument.msout.overwrite                     = True
concat_average0_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
concat_average0_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
concat_average0_data.argument.steps                               = []
{% if use_compression %}
concat_average0_data.argument.msout.storagemanager                = "Dysco"
concat_average0_data.argument.msout.storagemanager.databitrate    = 16
concat_average0_data.argument.msout.storagemanager.weightbitrate  = 12
concat_average0_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
concat_average0_data.argument.msout.storagemanager.disttruncation = 1.5
concat_average0_data.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile for concatenated averaged data MSs, length = 1
create_compressed_mapfile01.control.kind        = plugin
create_compressed_mapfile01.control.type        = compressMapfile
create_compressed_mapfile01.control.mapfile_in  = concat_average0_data.output.mapfile
create_compressed_mapfile01.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile01.control.filename    = image0_input.mapfile

# make a mask using user-supplied region (if any), length = 1
premask_selfcal.control.type                   = make_clean_mask
premask_selfcal.control.mapfile_in             = create_compressed_mapfile01.output.mapfile
premask_selfcal.control.inputkey               = imagefile
premask_selfcal.control.outputkey              = maskfile
premask_selfcal.argument.flags                 = [imagefile,maskfile]
premask_selfcal.argument.img_format            = fits
premask_selfcal.argument.pad_to_size           = {{ cal_imsize }}
premask_selfcal.argument.skip_source_detection = True
premask_selfcal.argument.vertices_file         = {{ vertices_file }}
premask_selfcal.argument.reference_ra_deg      = {{ ra }}
premask_selfcal.argument.reference_dec_deg     = {{ dec }}
premask_selfcal.argument.cellsize_deg          = {{ cellsize_selfcal_deg }}
premask_selfcal.argument.region_file           = {{ region_selfcal }}
premask_selfcal.argument.make_blank_image      = True
premask_selfcal.argument.trim_by               = 0.4

# image the concatenated data with wsclean, length = 1
wsclean_image02.control.type                    = wsclean
wsclean_image02.control.mapfiles_in             = [create_compressed_mapfile01.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image02.control.inputkeys               = [msfile,fitsmask]
wsclean_image02.argument.fitsmask               = fitsmask
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image02.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-local-rms,-joinchannels,msfile]
wsclean_image02.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image02.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-local-rms,msfile]
{% endif %}
wsclean_image02.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image02.argument.niter                  = 10000
wsclean_image02.argument.pol                    = I
wsclean_image02.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image02.argument.mgain                  = 0.8
wsclean_image02.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image02.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image02.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image02.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image02.argument.tempdir                = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image02.argument.tempdir                = {{ selfcal_local_dir }}
{% endif %}
wsclean_image02.argument.multiscale-shape       = gaussian
{% if not wsclean_selfcal_multiscale %}
wsclean_image02.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 %}
wsclean_image02.argument.fit-spectral-pol       = 3
{% elif wsclean_nchannels_selfcal > 1 %}
wsclean_image02.argument.fit-spectral-pol       = {{ wsclean_nchannels_selfcal - 1 }}
{% endif %}
wsclean_image02.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image02.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}
{% if region_selfcal != "[]" %}
wsclean_image02.argument.auto-mask              = 2.6
{% else %}
wsclean_image02.argument.auto-mask              = 3.6
{% endif %}
wsclean_image02.argument.auto-threshold         = 0.5
wsclean_image02.argument.local-rms-window       = 50
wsclean_image02.argument.local-rms-method       = rms-with-min

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map02.control.kind        = plugin
create_imagebase_map02.control.type        = trimMapfile
create_imagebase_map02.control.mapfile_in  = wsclean_image02.output.wsclean_image02-image.fits.mapfile
create_imagebase_map02.control.trim        = -
create_imagebase_map02.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map02.control.filename    = image02_rootname.mapfile

# pad the model image with zeros, length = 1
pad_selfcal_model0_images.control.type       = pad_image
pad_selfcal_model0_images.control.mapfile_in = create_imagebase_map02.output.mapfile
pad_selfcal_model0_images.control.inputkey   = imagefile
pad_selfcal_model0_images.argument.flags     = [imagefile]

# make compressed mapfile of concatenated data, length = ntimes
# needed for the wsclean_ft steps to get full frequency coverage per group
regroup_concat_data_map.control.kind               = plugin
regroup_concat_data_map.control.type               = compressMapfile
regroup_concat_data_map.control.mapfile_in         = {{ solve_concat_data_mapfile }}
regroup_concat_data_map.control.nitems_to_compress = {{ num_cal_blocks }}
regroup_concat_data_map.control.mapfile_dir        = input.output.mapfile_dir
regroup_concat_data_map.control.filename           = regroup_concat_data.mapfile

# expand the mapfile of the model image to match ft files, length = ntimes
create_expanded_model0_mapfile.control.kind             = plugin
create_expanded_model0_mapfile.control.type             = expandMapfile
create_expanded_model0_mapfile.control.mapfile_in       = create_imagebase_map02.output.mapfile
create_expanded_model0_mapfile.control.mapfile_to_match = regroup_concat_data_map.output.mapfile
create_expanded_model0_mapfile.control.mapfile_dir      = input.output.mapfile_dir
create_expanded_model0_mapfile.control.filename         = expand_model0.mapfile

# expand mapfile of the model image sizes to all groups, length = ntimes
expand_selfcal_model_size_map.control.kind             = plugin
expand_selfcal_model_size_map.control.type             = expandMapfile
expand_selfcal_model_size_map.control.mapfile_in       = pad_selfcal_model0_images.output.padsize.mapfile
expand_selfcal_model_size_map.control.mapfile_to_match = regroup_concat_data_map.output.mapfile
expand_selfcal_model_size_map.control.mapfile_dir      = input.output.mapfile_dir
expand_selfcal_model_size_map.control.filename         = expand_selfcal_model_size.mapfile

# predict model visibilities, length = ntimes
wsclean_ft0.control.type         = wsclean_ft
wsclean_ft0.control.mapfiles_in  = [regroup_concat_data_map.output.mapfile,create_expanded_model0_mapfile.output.mapfile,expand_selfcal_model_size_map.output.mapfile]
wsclean_ft0.control.inputkeys    = [msfile,name,size]
wsclean_ft0.argument.flags       = [-predict,msfile]
wsclean_ft0.argument.scale       = {{ cellsize_selfcal_deg }}
wsclean_ft0.argument.mem         = {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft0.argument.channelsout = {{ wsclean_nchannels_selfcal }}
wsclean_ft0.argument.j           = {{ max_cpus_per_io_proc_ntimes }}
{% if selfcal_local_dir is none and local_dir is not none %}
# WSClean uses selfcal_local_dir automatically if the output files are there
wsclean_ft0.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

# generate mapfile for the fast-phase parmDBs generated in the solve_phaseonly steps, length = ntimes * num_cal_blocks
make_fast_phase_parmdb_map.control.kind               = plugin
make_fast_phase_parmdb_map.control.type               = createMapfile
make_fast_phase_parmdb_map.control.method             = add_suffix_to_file
make_fast_phase_parmdb_map.control.mapfile_in         = concat_data.output.mapfile
make_fast_phase_parmdb_map.control.add_suffix_to_file = /instrument
make_fast_phase_parmdb_map.control.mapfile_dir        = input.output.mapfile_dir
make_fast_phase_parmdb_map.control.filename           = fast_parmdb.mapfile

{% if peel_skymodel is not none %}
# create a mapfile with the outlier skymodel from supplied list, length = 1
create_peel_skymodel_map.control.kind        = plugin
create_peel_skymodel_map.control.type        = addListMapfile
create_peel_skymodel_map.control.hosts       = {{ hosts }}
create_peel_skymodel_map.control.files       = [{{ peel_skymodel }}]
create_peel_skymodel_map.control.mapfile_dir = input.output.mapfile_dir
create_peel_skymodel_map.control.filename    = peel_skymodel.mapfile

# convert the outlier skymodel into a sourcedb, length = 1
make_peel_sourcedb.control.type       = make_sourcedb
make_peel_sourcedb.control.mapfile_in = create_peel_skymodel_map.output.mapfile
make_peel_sourcedb.control.inputkey   = in
make_peel_sourcedb.argument.format    = <
make_peel_sourcedb.argument.outtype   = blob
make_peel_sourcedb.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = ntimes * num_cal_blocks
expand_peel_sourcedb_map.control.kind             = plugin
expand_peel_sourcedb_map.control.type             = expandMapfile
expand_peel_sourcedb_map.control.mapfile_in       = make_peel_sourcedb.output.mapfile
expand_peel_sourcedb_map.control.mapfile_to_match = concat_data.output.mapfile
expand_peel_sourcedb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_peel_sourcedb_map.control.filename         = expand_peel_sourcedb.mapfile
{% endif %}

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs1.control.type       = remove_file
remove_parmdbs1.control.mapfile_in = make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs1.control.inputkey   = parmdb
remove_parmdbs1.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_phaseonly1.control.type                     = dppp_inplace
{% if peel_skymodel is not none %}
solve_phaseonly1.control.mapfiles_in              = [{{ solve_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile,expand_peel_sourcedb_map.output.mapfile]
solve_phaseonly1.control.inputkeys                = [msin,parmdb,sourcedb]
{% else %}
solve_phaseonly1.control.mapfiles_in              = [{{ solve_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
solve_phaseonly1.control.inputkeys                = [msin,parmdb]
{% endif %}
solve_phaseonly1.argument.numthreads              = {{ max_cpus_per_proc_ntimes }}
solve_phaseonly1.argument.msin.datacolumn         = DATA
solve_phaseonly1.argument.msout                   = .
solve_phaseonly1.argument.steps                   = [uvcut,solvetec]
solve_phaseonly1.argument.uvcut.type              = uvwflagger
solve_phaseonly1.argument.uvcut.uvlambdamin       = {{ solve_min_uv_lambda }}
solve_phaseonly1.argument.solvetec.type           = gaincal
solve_phaseonly1.argument.solvetec.caltype        = tecandphase
solve_phaseonly1.argument.solvetec.parmdb         = parmdb
{% if peel_skymodel is not none %}
solve_phaseonly1.argument.solvetec.usemodelcolumn = False
solve_phaseonly1.argument.solvetec.sourcedb       = sourcedb
{% else %}
solve_phaseonly1.argument.solvetec.usemodelcolumn = True
{% endif %}
solve_phaseonly1.argument.solvetec.solint         = {{ solint_time_p }}
solve_phaseonly1.argument.solvetec.nchan          = {{ solint_freq_a }}

########## end of first round of selfcal
########## start of second round of selfcal

{% if selfcal_local_dir is not none %}
# make mapfile for the output of apply steps, len = ntimes * num_cal_blocks
# this step is needed to direct the output to the shared disk if one is being
# used with mulitple nodes
make_apply_mapfile.control.kind         = plugin
make_apply_mapfile.control.type         = changeDirectory
{% if not pre_average %}
make_apply_mapfile.control.mapfile_in   = make_concat_data_sync_mapfile.output.mapfile
{% else %}
make_apply_mapfile.control.mapfile_in   = make_concat_blavg_data_sync_mapfile.output.mapfile
{% endif %}
make_apply_mapfile.control.new_dir      = {{ pipeline_parset_dir }}
make_apply_mapfile.control.append       = _apply_output
make_apply_mapfile.control.mapfile_dir  = input.output.mapfile_dir
make_apply_mapfile.control.filename     = apply_output.mapfile
{% endif %}

# apply the previous calibration and average, length = ntimes * num_cal_blocks
apply_phaseonly1.control.type                                 = dppp
apply_phaseonly1.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_phaseonly1.control.inputkeys                            = [msin,parmdb]
{% if selfcal_local_dir is not none %}
apply_phaseonly1.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_phaseonly1.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
apply_phaseonly1.argument.msin.datacolumn                     = DATA
apply_phaseonly1.argument.msout.overwrite                     = True
apply_phaseonly1.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_phaseonly1.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_phaseonly1.argument.steps                               = [correct_fast1,correct_fast2,avg]
apply_phaseonly1.argument.correct_fast1.type                  = applycal
apply_phaseonly1.argument.correct_fast1.parmdb                = parmdb
apply_phaseonly1.argument.correct_fast1.correction            = tec
apply_phaseonly1.argument.correct_fast1.invert                = True
apply_phaseonly1.argument.correct_fast2.type                  = applycal
apply_phaseonly1.argument.correct_fast2.parmdb                = parmdb
apply_phaseonly1.argument.correct_fast2.correction            = commonscalarphase
apply_phaseonly1.argument.correct_fast2.invert                = True
apply_phaseonly1.argument.avg.type                            = squash
apply_phaseonly1.argument.avg.freqstep                        = 1
apply_phaseonly1.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_phaseonly1.argument.msout.storagemanager                = "Dysco"
apply_phaseonly1.argument.msout.storagemanager.databitrate    = 16
apply_phaseonly1.argument.msout.storagemanager.weightbitrate  = 12
apply_phaseonly1.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_phaseonly1.argument.msout.storagemanager.disttruncation = 1.5
apply_phaseonly1.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile1.control.kind        = plugin
create_compressed_mapfile1.control.type        = compressMapfile
create_compressed_mapfile1.control.mapfile_in  = apply_phaseonly1.output.mapfile
create_compressed_mapfile1.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile1.control.filename    = image1_input.mapfile

# image the concatenated data with wsclean, length = 1
wsclean_image12.control.type                    = wsclean
wsclean_image12.control.mapfiles_in             = [create_compressed_mapfile1.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image12.control.inputkeys               = [msfile,fitsmask]
wsclean_image12.argument.fitsmask               = fitsmask
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image12.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-local-rms,-joinchannels,msfile]
wsclean_image12.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image12.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-local-rms,msfile]
{% endif %}
wsclean_image12.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image12.argument.niter                  = 10000
wsclean_image12.argument.pol                    = I
wsclean_image12.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image12.argument.mgain                  = 0.8
wsclean_image12.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image12.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image12.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image12.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image12.argument.tempdir                = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image12.argument.tempdir                = {{ selfcal_local_dir }}
{% endif %}
wsclean_image12.argument.multiscale-shape       = gaussian
{% if not wsclean_selfcal_multiscale %}
wsclean_image12.argument.multiscale-scales      = 0
{% endif %}
{% if wsclean_nchannels_selfcal > 3 %}
wsclean_image12.argument.fit-spectral-pol       = 3
{% elif wsclean_nchannels_selfcal > 1 %}
wsclean_image12.argument.fit-spectral-pol       = {{ wsclean_nchannels_selfcal - 1 }}
{% endif %}
wsclean_image12.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image12.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}
{% if region_selfcal != "[]" %}
wsclean_image12.argument.auto-mask              = 2.3
{% else %}
wsclean_image12.argument.auto-mask              = 3.3
{% endif %}
wsclean_image12.argument.auto-threshold         = 0.5
wsclean_image12.argument.local-rms-window       = 50
wsclean_image12.argument.local-rms-method       = rms-with-min

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map12.control.kind        = plugin
create_imagebase_map12.control.type        = trimMapfile
create_imagebase_map12.control.mapfile_in  = wsclean_image12.output.wsclean_image12-image.fits.mapfile
create_imagebase_map12.control.trim        = -
create_imagebase_map12.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map12.control.filename    = wsclean_image12_image_rootname.mapfile

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model1_mapfile.control.kind             = plugin
create_expanded_model1_mapfile.control.type             = expandMapfile
create_expanded_model1_mapfile.control.mapfile_in       = create_imagebase_map12.output.mapfile
create_expanded_model1_mapfile.control.mapfile_to_match = regroup_concat_data_map.output.mapfile
create_expanded_model1_mapfile.control.mapfile_dir      = input.output.mapfile_dir
create_expanded_model1_mapfile.control.filename         = expand_wsclean_model1.mapfile

## pad the model image with zeros, length = 1
pad_selfcal_model1_images.control.type       = pad_image
pad_selfcal_model1_images.control.mapfile_in = create_imagebase_map12.output.mapfile
pad_selfcal_model1_images.control.inputkey   = imagefile
pad_selfcal_model1_images.argument.flags     = [imagefile]

# predict model visibilities, length = ntimes
wsclean_ft1.control.type         = wsclean_ft
wsclean_ft1.control.mapfiles_in  = [regroup_concat_data_map.output.mapfile,create_expanded_model1_mapfile.output.mapfile,expand_selfcal_model_size_map.output.mapfile]
wsclean_ft1.control.inputkeys    = [msfile,name,size]
wsclean_ft1.argument.flags       = [-predict,msfile]
wsclean_ft1.argument.scale       = {{ cellsize_selfcal_deg }}
wsclean_ft1.argument.mem         = {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft1.argument.channelsout = {{ wsclean_nchannels_selfcal }}
wsclean_ft1.argument.j           = {{ max_cpus_per_io_proc_ntimes }}
{% if selfcal_local_dir is none and local_dir is not none %}
# WSClean uses selfcal_local_dir automatically if the output files are there
wsclean_ft1.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs2.control.type       = remove_file
remove_parmdbs2.control.mapfile_in = make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs2.control.inputkey   = parmdb
remove_parmdbs2.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_phaseonly2.control.type                     = dppp_inplace
solve_phaseonly2.control.mapfiles_in              = [{{ solve_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
solve_phaseonly2.control.inputkeys                = [msin,parmdb]
solve_phaseonly2.argument.numthreads              = {{ max_cpus_per_proc_ntimes }}
solve_phaseonly2.argument.msin.datacolumn         = DATA
solve_phaseonly2.argument.msout                   = .
solve_phaseonly2.argument.steps                   = [uvcut,solvetec]
solve_phaseonly2.argument.uvcut.type              = uvwflagger
solve_phaseonly2.argument.uvcut.uvlambdamin       = {{ solve_min_uv_lambda }}
solve_phaseonly2.argument.solvetec.type           = gaincal
solve_phaseonly2.argument.solvetec.caltype        = tecandphase
solve_phaseonly2.argument.solvetec.parmdb         = parmdb
solve_phaseonly2.argument.solvetec.usemodelcolumn = True
solve_phaseonly2.argument.solvetec.solint         = {{ solint_time_p }}
solve_phaseonly2.argument.solvetec.nchan          = {{ solint_freq_a }}

########## end of second round of selfcal
########## start of third round of selfcal

# apply the previous calibration and average, length = ntimes * num_cal_blocks
apply_phaseonly2.control.type                                 = dppp
apply_phaseonly2.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_phaseonly2.control.inputkeys                            = [msin,parmdb]
{% if selfcal_local_dir is not none %}
apply_phaseonly2.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_phaseonly2.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
apply_phaseonly2.argument.msin.datacolumn                     = DATA
apply_phaseonly2.argument.msout.overwrite                     = True
apply_phaseonly2.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_phaseonly2.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_phaseonly2.argument.steps                               = [correct_fast1,correct_fast2,avg]
apply_phaseonly2.argument.correct_fast1.type                  = applycal
apply_phaseonly2.argument.correct_fast1.parmdb                = parmdb
apply_phaseonly2.argument.correct_fast1.correction            = tec
apply_phaseonly2.argument.correct_fast1.invert                = True
apply_phaseonly2.argument.correct_fast2.type                  = applycal
apply_phaseonly2.argument.correct_fast2.parmdb                = parmdb
apply_phaseonly2.argument.correct_fast2.correction            = commonscalarphase
apply_phaseonly2.argument.correct_fast2.invert                = True
apply_phaseonly2.argument.avg.type                            = squash
apply_phaseonly2.argument.avg.freqstep                        = 1
apply_phaseonly2.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_phaseonly2.argument.msout.storagemanager                = "Dysco"
apply_phaseonly2.argument.msout.storagemanager.databitrate    = 16
apply_phaseonly2.argument.msout.storagemanager.weightbitrate  = 12
apply_phaseonly2.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_phaseonly2.argument.msout.storagemanager.disttruncation = 1.5
apply_phaseonly2.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile2.control.kind        = plugin
create_compressed_mapfile2.control.type        = compressMapfile
create_compressed_mapfile2.control.mapfile_in  = apply_phaseonly2.output.mapfile
create_compressed_mapfile2.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile2.control.filename    = image2_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image22.control.type                    = wsclean
wsclean_image22.control.mapfiles_in             = [create_compressed_mapfile2.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image22.control.inputkeys               = [msfile,fitsmask]
wsclean_image22.argument.fitsmask               = fitsmask
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image22.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-local-rms,-joinchannels,msfile]
wsclean_image22.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image22.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-local-rms,msfile]
{% endif %}
wsclean_image22.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image22.argument.niter                  = 10000
wsclean_image22.argument.pol                    = I
wsclean_image22.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image22.argument.mgain                  = 0.8
wsclean_image22.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image22.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image22.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image22.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image22.argument.tempdir                = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image22.argument.tempdir                = {{ selfcal_local_dir }}
{% endif %}
wsclean_image22.argument.multiscale-shape       = gaussian
{% if not wsclean_selfcal_multiscale %}
wsclean_image22.argument.multiscale-scales      = 0,7
{% endif %}
{% if wsclean_nchannels_selfcal > 3 %}
wsclean_image22.argument.fit-spectral-pol       = 3
{% elif wsclean_nchannels_selfcal > 1 %}
wsclean_image22.argument.fit-spectral-pol       = {{ wsclean_nchannels_selfcal - 1 }}
{% endif %}
wsclean_image22.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image22.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}
{% if region_selfcal != "[]" %}
wsclean_image22.argument.auto-mask              = 2.0
{% else %}
wsclean_image22.argument.auto-mask              = 3.0
{% endif %}
wsclean_image22.argument.auto-threshold         = 0.5
wsclean_image22.argument.local-rms-window       = 50
wsclean_image22.argument.local-rms-method       = rms-with-min
wsclean_image22.argument.multiscale-scale-bias  = 0.5
wsclean_image22.argument.multiscale-gain        = 0.1

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map22.control.kind        = plugin
create_imagebase_map22.control.type        = trimMapfile
create_imagebase_map22.control.mapfile_in  = wsclean_image22.output.wsclean_image22-image.fits.mapfile
create_imagebase_map22.control.trim        = -
create_imagebase_map22.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map22.control.filename    = wsclean_image22_image_rootname.mapfile

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model2_mapfile.control.kind             = plugin
create_expanded_model2_mapfile.control.type             = expandMapfile
create_expanded_model2_mapfile.control.mapfile_in       = create_imagebase_map22.output.mapfile
create_expanded_model2_mapfile.control.mapfile_to_match = regroup_concat_data_map.output.mapfile
create_expanded_model2_mapfile.control.mapfile_dir      = input.output.mapfile_dir
create_expanded_model2_mapfile.control.filename         = expand_wsclean_model1.mapfile

# pad the model image with zeros, length = 1
pad_selfcal_model2_images.control.type       = pad_image
pad_selfcal_model2_images.control.mapfile_in = create_imagebase_map22.output.mapfile
pad_selfcal_model2_images.control.inputkey   = imagefile
pad_selfcal_model2_images.argument.flags     = [imagefile]

# predict model visibilities, length = ntimes
wsclean_ft2.control.type         = wsclean_ft
wsclean_ft2.control.mapfiles_in  = [regroup_concat_data_map.output.mapfile,create_expanded_model2_mapfile.output.mapfile,expand_selfcal_model_size_map.output.mapfile]
wsclean_ft2.control.inputkeys    = [msfile,name,size]
wsclean_ft2.argument.flags       = [-predict,msfile]
wsclean_ft2.argument.scale       = {{ cellsize_selfcal_deg }}
wsclean_ft2.argument.mem         = {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft2.argument.channelsout = {{ wsclean_nchannels_selfcal }}
wsclean_ft2.argument.j           = {{ max_cpus_per_io_proc_ntimes }}
{% if selfcal_local_dir is none and local_dir is not none %}
# WSClean uses selfcal_local_dir automatically if the output files are there
wsclean_ft2.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs11.control.type       = remove_file
remove_parmdbs11.control.mapfile_in = make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs11.control.inputkey   = parmdb
remove_parmdbs11.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase11.control.type                     = dppp_inplace
solve_ampphase11.control.mapfiles_in              = [{{ solve_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
solve_ampphase11.control.inputkeys                = [msin,parmdb]
solve_ampphase11.argument.numthreads              = {{ max_cpus_per_proc_ntimes }}
solve_ampphase11.argument.msin.datacolumn         = DATA
solve_ampphase11.argument.msout                   = .
solve_ampphase11.argument.steps                   = [uvcut,solvetec]
solve_ampphase11.argument.uvcut.type              = uvwflagger
solve_ampphase11.argument.uvcut.uvlambdamin       = {{ solve_min_uv_lambda }}
solve_ampphase11.argument.solvetec.type           = gaincal
solve_ampphase11.argument.solvetec.caltype        = tecandphase
solve_ampphase11.argument.solvetec.parmdb         = parmdb
solve_ampphase11.argument.solvetec.usemodelcolumn = True
solve_ampphase11.argument.solvetec.solint         = {{ solint_time_p }}
solve_ampphase11.argument.solvetec.nchan          = {{ solint_freq_a }}

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase11.control.type                                 = dppp_inplace
apply_ampphase11.control.mapfiles_in                          = [{{ solve_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_ampphase11.control.inputkeys                            = [msin,parmdb]
apply_ampphase11.argument.numthreads                          = {{ max_cpus_per_proc_ntimes }}
apply_ampphase11.argument.msin.datacolumn                     = DATA
apply_ampphase11.argument.msout                               = .
apply_ampphase11.argument.msout.datacolumn                    = CORRECTED_DATA
apply_ampphase11.argument.steps                               = [correct_fast1,correct_fast2]
apply_ampphase11.argument.correct_fast1.type                  = applycal
apply_ampphase11.argument.correct_fast1.parmdb                = parmdb
apply_ampphase11.argument.correct_fast1.correction            = tec
apply_ampphase11.argument.correct_fast1.invert                = True
apply_ampphase11.argument.correct_fast2.type                  = applycal
apply_ampphase11.argument.correct_fast2.parmdb                = parmdb
apply_ampphase11.argument.correct_fast2.correction            = commonscalarphase
apply_ampphase11.argument.correct_fast2.invert                = True
{% if use_compression %}
apply_ampphase11.argument.msout.storagemanager                = "Dysco"
apply_ampphase11.argument.msout.storagemanager.databitrate    = 16
apply_ampphase11.argument.msout.storagemanager.weightbitrate  = 12
apply_ampphase11.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_ampphase11.argument.msout.storagemanager.disttruncation = 1.5
apply_ampphase11.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# generate mapfile for the slow-gain parmDBs generated in the solve_ampphase12 step
make_slow_gain_parmdb_map.control.kind               =  plugin
make_slow_gain_parmdb_map.control.type               =  createMapfile
make_slow_gain_parmdb_map.control.method             =  add_suffix_to_file
make_slow_gain_parmdb_map.control.mapfile_in         =  concat_data.output.mapfile
make_slow_gain_parmdb_map.control.add_suffix_to_file =  /instrument_slow
make_slow_gain_parmdb_map.control.mapfile_dir        =  input.output.mapfile_dir
make_slow_gain_parmdb_map.control.filename           =  slow_parmdb.mapfile

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs12.control.type       = remove_file
remove_parmdbs12.control.mapfile_in = make_slow_gain_parmdb_map.output.mapfile
remove_parmdbs12.control.inputkey   = parmdb
remove_parmdbs12.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase12.control.type                      = dppp_inplace
solve_ampphase12.control.mapfiles_in               = [{{ solve_concat_data_mapfile }},make_slow_gain_parmdb_map.output.mapfile]
solve_ampphase12.control.inputkeys                 = [msin,parmdb]
solve_ampphase12.argument.numthreads               = {{ max_cpus_per_proc_ntimes }}
solve_ampphase12.argument.msin.datacolumn          = CORRECTED_DATA
solve_ampphase12.argument.msout                    = .
solve_ampphase12.argument.steps                    = [uvcut,solvegain]
solve_ampphase12.argument.uvcut.type               = uvwflagger
solve_ampphase12.argument.uvcut.uvlambdamin        = {{ solve_min_uv_lambda }}
solve_ampphase12.argument.solvegain.type           = gaincal
solve_ampphase12.argument.solvegain.caltype        = {{ selfcal_caltype }}
solve_ampphase12.argument.solvegain.parmdb         = parmdb
solve_ampphase12.argument.solvegain.usemodelcolumn = True
solve_ampphase12.argument.solvegain.solint         = {{ solint_time_a }}
solve_ampphase12.argument.solvegain.nchan          = {{ solint_freq_a }}

# merge the parmDBs with the amplitude solutions into one, length = 1
merge_amp_parmdbs1.control.type         = merge_parmdbs_in_time
merge_amp_parmdbs1.control.mapfile_in   = concat_data_compressed_mapfile.output.mapfile
merge_amp_parmdbs1.control.inputkey     = mslist
merge_amp_parmdbs1.control.outputkey    = outparmdb
merge_amp_parmdbs1.argument.flags       = [mslist,instrument_slow,outparmdb]
{% if selfcal_local_dir is not none %}
merge_amp_parmdbs1.argument.scratch_dir = {{ selfcal_local_dir }}
{% endif %}

# smooth the amplitues in the merged parmDB, length = 1
smooth_amp1.control.type         = {{ smooth_amps_task }}
smooth_amp1.control.mapfile_in   = merge_amp_parmdbs1.output.mapfile
smooth_amp1.control.inputkey     = ampparmdb
smooth_amp1.control.outputkey    = outparmdb
smooth_amp1.argument.flags       = [ampparmdb,outparmdb]
{% if selfcal_local_dir is not none %}
smooth_amp1.argument.scratch_dir = {{ selfcal_local_dir }}
{% endif %}

# expand the mapfile with the smoothd parmDB to all time-steps, length = ntimes * num_cal_blocks
expand_smoothed_amp1_parmdb_map.control.kind             = plugin
expand_smoothed_amp1_parmdb_map.control.type             = expandMapfile
expand_smoothed_amp1_parmdb_map.control.mapfile_in       = smooth_amp1.output.mapfile
expand_smoothed_amp1_parmdb_map.control.mapfile_to_match = concat_data.output.mapfile
expand_smoothed_amp1_parmdb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_smoothed_amp1_parmdb_map.control.filename         = expand_amp1_smoothed_parmdbs.mapfile

# apply the smoothed amplitudes and average, length = ntimes * num_cal_blocks
apply_amp1.control.type                                 = dppp
{% if selfcal_local_dir is not none %}
apply_amp1.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_amp1.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
{% if not pre_average %}
apply_amp1.control.mapfiles_in                          = [{{ concat_data_mapfile }},expand_smoothed_amp1_parmdb_map.output.mapfile]
apply_amp1.control.inputkeys                            = [msin,parmdb]
apply_amp1.argument.msin.datacolumn                     = CORRECTED_DATA
apply_amp1.argument.steps                               = [correct_slow,avg]
{% else %}
apply_amp1.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile,expand_smoothed_amp1_parmdb_map.output.mapfile]
apply_amp1.control.inputkeys                            = [msin,fast_parmdb,parmdb]
apply_amp1.argument.msin.datacolumn                     = DATA
apply_amp1.argument.steps                               = [correct_fast1,correct_fast2,correct_slow,avg]
apply_amp1.argument.correct_fast1.type                  = applycal
apply_amp1.argument.correct_fast1.parmdb                = fast_parmdb
apply_amp1.argument.correct_fast1.correction            = tec
apply_amp1.argument.correct_fast1.invert                = True
apply_amp1.argument.correct_fast2.type                  = applycal
apply_amp1.argument.correct_fast2.parmdb                = fast_parmdb
apply_amp1.argument.correct_fast2.correction            = commonscalarphase
apply_amp1.argument.correct_fast2.invert                = True
{% endif %}
apply_amp1.argument.msout.overwrite                     = True
apply_amp1.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_amp1.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_amp1.argument.correct_slow.type                   = applycal
apply_amp1.argument.correct_slow.parmdb                 = parmdb
apply_amp1.argument.correct_slow.invert                 = True
apply_amp1.argument.avg.type                            = squash
apply_amp1.argument.avg.freqstep                        = 1
apply_amp1.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_amp1.argument.msout.storagemanager                = "Dysco"
apply_amp1.argument.msout.storagemanager.databitrate    = 16
apply_amp1.argument.msout.storagemanager.weightbitrate  = 12
apply_amp1.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_amp1.argument.msout.storagemanager.disttruncation = 1.5
apply_amp1.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

########## end of third round of selfcal
########## start of fourth round of selfcal

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile3.control.kind        = plugin
create_compressed_mapfile3.control.type        = compressMapfile
create_compressed_mapfile3.control.mapfile_in  = apply_amp1.output.mapfile
create_compressed_mapfile3.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile3.control.filename    = image3_input.mapfile

# image the concatenated data with wsclean, length = 1
wsclean_image32.control.type                    = wsclean
wsclean_image32.control.mapfiles_in             = [create_compressed_mapfile3.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image32.control.inputkeys               = [msfile,fitsmask]
wsclean_image32.argument.fitsmask               = fitsmask
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image32.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-local-rms,-joinchannels,msfile]
wsclean_image32.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image32.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-local-rms,msfile]
{% endif %}
wsclean_image32.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image32.argument.niter                  = 10000
wsclean_image32.argument.pol                    = I
wsclean_image32.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image32.argument.mgain                  = 0.8
wsclean_image32.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image32.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image32.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image32.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image32.argument.tempdir                = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image32.argument.tempdir                = {{ selfcal_local_dir }}
{% endif %}
wsclean_image32.argument.multiscale-shape       = gaussian
{% if not wsclean_selfcal_multiscale %}
wsclean_image32.argument.multiscale-scales      = 0,7
{% endif %}
{% if wsclean_nchannels_selfcal > 3 %}
wsclean_image32.argument.fit-spectral-pol       = 3
{% elif wsclean_nchannels_selfcal > 1 %}
wsclean_image32.argument.fit-spectral-pol       = {{ wsclean_nchannels_selfcal - 1 }}
{% endif %}
wsclean_image32.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image32.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}
{% if region_selfcal != "[]" %}
wsclean_image32.argument.auto-mask              = 2.5
{% else %}
wsclean_image32.argument.auto-mask              = 3.5
{% endif %}
wsclean_image32.argument.auto-threshold         = 0.5
wsclean_image32.argument.local-rms-window       = 50
wsclean_image32.argument.local-rms-method       = rms-with-min
wsclean_image32.argument.multiscale-scale-bias  = 0.5
wsclean_image32.argument.multiscale-gain        = 0.1

########## start of selfcal loop

# loop step
loop_ampcal.control.kind      = loop
loop_ampcal.control.type      = conditional
loop_ampcal.control.loopcount = {{ loopcount }}
loop_ampcal.control.loopsteps = [create_imagebase_map32,create_expanded_model3_mapfile,pad_selfcal_model3_images,wsclean_ft3,remove_parmdbs21,solve_ampphase21,apply_ampphase21,merge_phase_parmdbs,remove_parmdbs22,solve_ampphase22,merge_amp_parmdbs2,smooth_amp2,expand_smoothed_amp2_parmdb_map,apply_amp2,create_compressed_mapfile4,wsclean_image42,create_imagebase_map42,adjust_wsclean_mapfile42,copy_image,check_image]

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map32.control.kind        = plugin
create_imagebase_map32.control.type        = trimMapfile
create_imagebase_map32.control.mapfile_in  = wsclean_image32.output.wsclean_image32-image.fits.mapfile
create_imagebase_map32.control.trim        = -
create_imagebase_map32.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map32.control.filename    = model3_rootnames.mapfile
create_imagebase_map32.control.counter     = loop_ampcal.output.counter

# expand the mapfile of the model image to all files, length = ntimes
create_expanded_model3_mapfile.control.kind             = plugin
create_expanded_model3_mapfile.control.type             = expandMapfile
create_expanded_model3_mapfile.control.mapfile_in       = create_imagebase_map32.output.mapfile
create_expanded_model3_mapfile.control.mapfile_to_match = regroup_concat_data_map.output.mapfile
create_expanded_model3_mapfile.control.mapfile_dir      = input.output.mapfile_dir
create_expanded_model3_mapfile.control.filename         = expand_wsclean_model1.mapfile

# pad the model image with zeros, length = 1
pad_selfcal_model3_images.control.type       = pad_image
pad_selfcal_model3_images.control.mapfile_in = create_imagebase_map32.output.mapfile
pad_selfcal_model3_images.control.inputkey   = imagefile
pad_selfcal_model3_images.argument.flags     = [imagefile]

# predict model visibilities, length =  times
wsclean_ft3.control.type         = wsclean_ft
wsclean_ft3.control.mapfiles_in  = [regroup_concat_data_map.output.mapfile,create_expanded_model3_mapfile.output.mapfile,expand_selfcal_model_size_map.output.mapfile]
wsclean_ft3.control.inputkeys    = [msfile,name,size]
wsclean_ft3.argument.flags       = [-predict,msfile]
wsclean_ft3.argument.scale       = {{ cellsize_selfcal_deg }}
wsclean_ft3.argument.mem         = {{ max_percent_memory_per_io_proc_ntimes }}
wsclean_ft3.argument.channelsout = {{ wsclean_nchannels_selfcal }}
wsclean_ft3.argument.j           = {{ max_cpus_per_io_proc_ntimes }}
{% if selfcal_local_dir is none and local_dir is not none %}
# WSClean uses selfcal_local_dir automatically if the output files are there
wsclean_ft3.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs21.control.type       = remove_file
remove_parmdbs21.control.mapfile_in = make_fast_phase_parmdb_map.output.mapfile
remove_parmdbs21.control.inputkey   = parmdb
remove_parmdbs21.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (fast) phases, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase21.control.type                     = dppp_inplace
solve_ampphase21.control.mapfiles_in              = [{{ solve_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
solve_ampphase21.control.inputkeys                = [msin,parmdb]
solve_ampphase21.argument.numthreads              = {{ max_cpus_per_proc_ntimes }}
solve_ampphase21.argument.msin.datacolumn         = DATA
solve_ampphase21.argument.msout                   = .
solve_ampphase21.argument.steps                   = [uvcut,solvetec]
solve_ampphase21.argument.uvcut.type              = uvwflagger
solve_ampphase21.argument.uvcut.uvlambdamin       = {{ solve_min_uv_lambda }}
solve_ampphase21.argument.solvetec.type           = gaincal
solve_ampphase21.argument.solvetec.caltype        = tecandphase
solve_ampphase21.argument.solvetec.parmdb         = parmdb
solve_ampphase21.argument.solvetec.usemodelcolumn = True
solve_ampphase21.argument.solvetec.solint         = {{ solint_time_p }}
solve_ampphase21.argument.solvetec.nchan          = {{ solint_freq_a }}

# apply the phase-only solutions from the previous calibration, length = ntimes * num_cal_blocks
apply_ampphase21.control.type                                 = dppp_inplace
apply_ampphase21.control.mapfiles_in                          = [{{ solve_concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile]
apply_ampphase21.control.inputkeys                            = [msin,parmdb]
apply_ampphase21.argument.numthreads                          = {{ max_cpus_per_proc_ntimes }}
apply_ampphase21.argument.msin.datacolumn                     = DATA
apply_ampphase21.argument.msout                               = .
apply_ampphase21.argument.msout.datacolumn                    = CORRECTED_DATA
apply_ampphase21.argument.steps                               = [correct_fast1,correct_fast2]
apply_ampphase21.argument.correct_fast1.type                  = applycal
apply_ampphase21.argument.correct_fast1.parmdb                = parmdb
apply_ampphase21.argument.correct_fast1.correction            = tec
apply_ampphase21.argument.correct_fast1.invert                = True
apply_ampphase21.argument.correct_fast2.type                  = applycal
apply_ampphase21.argument.correct_fast2.parmdb                = parmdb
apply_ampphase21.argument.correct_fast2.correction            = commonscalarphase
apply_ampphase21.argument.correct_fast2.invert                = True
{% if use_compression %}
apply_ampphase21.argument.msout.storagemanager                = "Dysco"
apply_ampphase21.argument.msout.storagemanager.databitrate    = 16
apply_ampphase21.argument.msout.storagemanager.weightbitrate  = 12
apply_ampphase21.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_ampphase21.argument.msout.storagemanager.disttruncation = 1.5
apply_ampphase21.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# merge the parmDBs with the phase solutions into one, length = 1
# This is needed later when the loop is done and we want to apply the solutions to the original data
merge_phase_parmdbs.control.type       = merge_parmdbs_in_time
merge_phase_parmdbs.control.mapfile_in = concat_data_compressed_mapfile.output.mapfile
merge_phase_parmdbs.control.inputkey   = mslist
merge_phase_parmdbs.control.outputkey  = outparmdb
merge_phase_parmdbs.argument.flags     = [mslist,instrument,outparmdb]

# remove any existing parmdbs before solving, length = ntimes * num_cal_blocks
remove_parmdbs22.control.type       = remove_file
remove_parmdbs22.control.mapfile_in = make_slow_gain_parmdb_map.output.mapfile
remove_parmdbs22.control.inputkey   = parmdb
remove_parmdbs22.argument.flags     = [-rf,parmdb]

# run GainCal with model column on freq-concatenated files, to solve for (slow) amplitudes, length = ntimes * num_cal_blocks
# note: for now, we use the uvwflagger to exclude baselines shorter than solve_min_uv_lambda. Once
# GainCal has a filter parameter, we can switch to that
solve_ampphase22.control.type                      = dppp_inplace
solve_ampphase22.control.mapfiles_in               = [{{ solve_concat_data_mapfile }},make_slow_gain_parmdb_map.output.mapfile]
solve_ampphase22.control.inputkeys                 = [msin,parmdb]
solve_ampphase22.argument.numthreads               = {{ max_cpus_per_proc_ntimes }}
solve_ampphase22.argument.msin.datacolumn          = CORRECTED_DATA
solve_ampphase22.argument.msout                    = .
solve_ampphase22.argument.steps                    = [uvcut,solvegain]
solve_ampphase22.argument.uvcut.type               = uvwflagger
solve_ampphase22.argument.uvcut.uvlambdamin        = {{ solve_min_uv_lambda }}
solve_ampphase22.argument.solvegain.type           = gaincal
solve_ampphase22.argument.solvegain.caltype        = {{ selfcal_caltype }}
solve_ampphase22.argument.solvegain.parmdb         = parmdb
solve_ampphase22.argument.solvegain.usemodelcolumn = True
solve_ampphase22.argument.solvegain.solint         = {{ solint_time_a }}
solve_ampphase22.argument.solvegain.nchan          = {{ solint_freq_a }}

# merge the parmDBs with the amplitude solutions into one, length = 1
# This is also used after the loop, but also now for smoothing the amplitudes
merge_amp_parmdbs2.control.type         = merge_parmdbs_in_time
merge_amp_parmdbs2.control.mapfile_in   = concat_data_compressed_mapfile.output.mapfile
merge_amp_parmdbs2.control.inputkey     = mslist
merge_amp_parmdbs2.control.outputkey    = outparmdb
merge_amp_parmdbs2.argument.flags       = [mslist,instrument_slow,outparmdb]
{% if selfcal_local_dir is not none %}
merge_amp_parmdbs2.argument.scratch_dir = {{ selfcal_local_dir }}
{% endif %}

# smooth the amplitudes in the merged parmDB, length = 1
smooth_amp2.control.type         = {{ smooth_amps_task }}
smooth_amp2.control.mapfile_in   = merge_amp_parmdbs2.output.mapfile
smooth_amp2.control.inputkey     = ampparmdb
smooth_amp2.control.outputkey    = outparmdb
smooth_amp2.argument.flags       = [ampparmdb,outparmdb]
{% if selfcal_local_dir is not none %}
smooth_amp2.argument.scratch_dir = {{ selfcal_local_dir }}
{% endif %}

# expand the mapfile with the smoothd parmDB to all time-steps, length = ntimes * num_cal_blocks
expand_smoothed_amp2_parmdb_map.control.kind             = plugin
expand_smoothed_amp2_parmdb_map.control.type             = expandMapfile
expand_smoothed_amp2_parmdb_map.control.mapfile_in       = smooth_amp2.output.mapfile
expand_smoothed_amp2_parmdb_map.control.mapfile_to_match = concat_data.output.mapfile
expand_smoothed_amp2_parmdb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_smoothed_amp2_parmdb_map.control.filename         = expand_amp2_smoothed_parmdbs.mapfile

# apply the smoothed amplitudes and average, length = ntimes * num_cal_blocks
apply_amp2.control.type                                 = dppp
{% if selfcal_local_dir is not none %}
apply_amp2.control.mapfile_out                          = make_apply_mapfile.output.mapfile
{% endif %}
apply_amp2.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
{% if not pre_average %}
apply_amp2.control.mapfiles_in                          = [{{ concat_data_mapfile }},expand_smoothed_amp2_parmdb_map.output.mapfile]
apply_amp2.control.inputkeys                            = [msin,parmdb]
apply_amp2.argument.msin.datacolumn                     = CORRECTED_DATA
apply_amp2.argument.steps                               = [correct_slow,avg]
{% else %}
apply_amp2.control.mapfiles_in                          = [{{ concat_data_mapfile }},make_fast_phase_parmdb_map.output.mapfile,expand_smoothed_amp2_parmdb_map.output.mapfile]
apply_amp2.control.inputkeys                            = [msin,fast_parmdb,parmdb]
apply_amp2.argument.msin.datacolumn                     = DATA
apply_amp2.argument.steps                               = [correct_fast1,correct_fast2,correct_slow,avg]
apply_amp2.argument.correct_fast1.type                  = applycal
apply_amp2.argument.correct_fast1.parmdb                = fast_parmdb
apply_amp2.argument.correct_fast1.correction            = tec
apply_amp2.argument.correct_fast1.invert                = True
apply_amp2.argument.correct_fast2.type                  = applycal
apply_amp2.argument.correct_fast2.parmdb                = fast_parmdb
apply_amp2.argument.correct_fast2.correction            = commonscalarphase
apply_amp2.argument.correct_fast2.invert                = True
{% endif %}
apply_amp2.argument.msout.overwrite                     = True
apply_amp2.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
apply_amp2.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
apply_amp2.argument.correct_slow.type                   = applycal
apply_amp2.argument.correct_slow.parmdb                 = parmdb
apply_amp2.argument.correct_slow.invert                 = True
apply_amp2.argument.avg.type                            = squash
apply_amp2.argument.avg.freqstep                        = 1
apply_amp2.argument.avg.timestep                        = {{ facetselfcal_timestep }}
{% if use_compression %}
apply_amp2.argument.msout.storagemanager                = "Dysco"
apply_amp2.argument.msout.storagemanager.databitrate    = 16
apply_amp2.argument.msout.storagemanager.weightbitrate  = 12
apply_amp2.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
apply_amp2.argument.msout.storagemanager.disttruncation = 1.5
apply_amp2.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

########## end of fourth or of the looped round of selfcal

########## start of looped round of selfcal
########## make image to check if we can stop the loop, or as new model

# make compressed mapfile of averaged data, length = 1
create_compressed_mapfile4.control.kind        = plugin
create_compressed_mapfile4.control.type        = compressMapfile
create_compressed_mapfile4.control.mapfile_in  = apply_amp2.output.mapfile
create_compressed_mapfile4.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile4.control.filename    = image4_input.mapfile

# image the virtual concatenated data with wsclean, length = 1
wsclean_image42.control.type                    = wsclean
wsclean_image42.control.mapfiles_in             = [create_compressed_mapfile4.output.mapfile,premask_selfcal.output.mapfile]
wsclean_image42.control.inputkeys               = [msfile,fitsmask]
wsclean_image42.argument.fitsmask               = fitsmask
{% if wsclean_nchannels_selfcal > 1 %}
wsclean_image42.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-local-rms,-joinchannels,-save-source-list,msfile]
wsclean_image42.argument.channelsout            = {{ wsclean_nchannels_selfcal }}
{% else %}
wsclean_image42.argument.flags                  = [-no-update-model-required,-multiscale,-fitbeam,-reorder,-local-rms,-save-source-list,msfile]
{% endif %}
wsclean_image42.argument.size                   = {{ cal_imsize }} {{ cal_imsize }}
wsclean_image42.argument.niter                  = 10000
wsclean_image42.argument.pol                    = I
wsclean_image42.argument.weight                 = briggs {{ robust_selfcal }}
wsclean_image42.argument.mgain                  = 0.8
wsclean_image42.argument.minuv-l                = {{ selfcal_min_uv_lambda }}
wsclean_image42.argument.scale                  = {{ cellsize_selfcal_deg }}
wsclean_image42.argument.mem                    = {{ max_percent_memory_per_proc_single }}
wsclean_image42.argument.j                      = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image42.argument.tempdir                = {{ local_dir_parent }}
{% elif selfcal_local_dir is not none %}
wsclean_image42.argument.tempdir                = {{ selfcal_local_dir }}
{% endif %}
wsclean_image42.argument.multiscale-shape       = gaussian
{% if not wsclean_selfcal_multiscale %}
wsclean_image42.argument.multiscale-scales      = 0,7
{% endif %}
{% if wsclean_nchannels_selfcal > 3 %}
wsclean_image42.argument.fit-spectral-pol       = 3
{% elif wsclean_nchannels_selfcal > 1 %}
wsclean_image42.argument.fit-spectral-pol       = {{ wsclean_nchannels_selfcal - 1 }}
{% endif %}
wsclean_image42.argument.weighting-rank-filter  = 3
{% if facetselfcal_wsclean_nwavelengths > 0.0 %}
wsclean_image42.argument.baseline-averaging     = {{ facetselfcal_wsclean_nwavelengths }}
{% endif %}
{% if region_selfcal != "[]" %}
wsclean_image42.argument.auto-mask              = 2.0
{% else %}
wsclean_image42.argument.auto-mask              = 3.0
{% endif %}
wsclean_image42.argument.auto-threshold         = 0.5
wsclean_image42.argument.local-rms-window       = 50
wsclean_image42.argument.local-rms-method       = rms-with-min
wsclean_image42.argument.multiscale-scale-bias  = 0.5
wsclean_image42.argument.multiscale-gain        = 0.1

# make a mapfile with the root-name of the WSClean image, length = 1
create_imagebase_map42.control.kind        = plugin
create_imagebase_map42.control.type        = trimMapfile
create_imagebase_map42.control.mapfile_in  = wsclean_image42.output.wsclean_image42-image.fits.mapfile
create_imagebase_map42.control.trim        = -
create_imagebase_map42.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map42.control.filename    = wsclean_image41_image_rootname.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile42.control.kind        = plugin
adjust_wsclean_mapfile42.control.type        = appendMapfile
adjust_wsclean_mapfile42.control.mapfile_in  = create_imagebase_map42.output.mapfile
adjust_wsclean_mapfile42.control.append      = {{ wsclean_suffix }}
adjust_wsclean_mapfile42.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile42.control.filename    = compare_image_input_new.mapfile

# copy the output image so that we can compare it later, length = 1
copy_image.control.type       = copy_image
copy_image.control.mapfile_in = adjust_wsclean_mapfile42.output.mapfile
copy_image.control.inputkey   = image
copy_image.argument.flags     = [image,loop_ampcal.output.counter,4]

# compare the current and the previous image to see if we can stop the loop, length = 1
check_image.control.type        = compare_image_stats
check_image.control.mapfiles_in = [adjust_wsclean_mapfile42.output.mapfile,copy_image.output.previous_image.mapfile]
check_image.control.inputkeys   = [image_new,image_prev]
check_image.argument.flags      = [image_new,image_prev]

########## end of selfcal loop
{% endblock selfcal_parameters %}

{% if selfcal_local_dir is not none %}
{% if not pre_average %}
# remove concat_data files, length = ntimes * num_cal_blocks
remove_concat_data.control.type       = remove_synced_data
remove_concat_data.control.mapfile_in = make_concat_data_sync_mapfile.output.mapfile
remove_concat_data.control.inputkey   = msfile
remove_concat_data.argument.flags     = [msfile]

{% else %}
# remove concat_blavg_data files, length = ntimes * num_cal_blocks
remove_concat_blavg_data.control.type       = remove_synced_data
remove_concat_blavg_data.control.mapfile_in = make_concat_blavg_data_sync_mapfile.output.mapfile
remove_concat_blavg_data.control.inputkey   = msfile
remove_concat_blavg_data.argument.flags     = [msfile]
{% endif %}
{% endif %}

# merge the phase and amplitude parmDBs, length = 1
merge_selfcal_parmdbs.control.type        = merge_parmdbs_selfcal
merge_selfcal_parmdbs.control.mapfiles_in = [merge_phase_parmdbs.output.mapfile,smooth_amp2.output.mapfile]
merge_selfcal_parmdbs.control.inputkeys   = [parmdb_p,parmdb_a]
merge_selfcal_parmdbs.control.outputkey   = parmdb_out
merge_selfcal_parmdbs.argument.flags      = [parmdb_p,parmdb_a,parmdb_out]

# convert the merged phase and amplitude parmDBs to gain parmDBs, length = 1
# if phases are pre-applied, then also add them in
convert_merged_selfcal_parmdbs.control.type         = convert_solutions_to_gain
{% if preapply_phase_cal %}
convert_merged_selfcal_parmdbs.control.mapfiles_in  = [merge_phase_parmdbs.output.mapfile,smooth_amp2.output.mapfile,{{ preapply_parmdb_mapfile }}]
convert_merged_selfcal_parmdbs.control.inputkeys    = [fast_parmdb_in,slow_parmdb_in,parmdb_pre]
convert_merged_selfcal_parmdbs.argument.flags       = [fast_parmdb_in,slow_parmdb_in,parmdb_out,{{ facetselfcal_freqstep * solint_freq_a }},parmdb_pre]
{% else %}
convert_merged_selfcal_parmdbs.control.mapfiles_in  = [merge_phase_parmdbs.output.mapfile,smooth_amp2.output.mapfile]
convert_merged_selfcal_parmdbs.control.inputkeys    = [fast_parmdb_in,slow_parmdb_in]
convert_merged_selfcal_parmdbs.argument.flags       = [fast_parmdb_in,slow_parmdb_in,parmdb_out,{{ facetselfcal_freqstep * solint_freq_a }}]
{% endif %}
convert_merged_selfcal_parmdbs.control.outputkey    = parmdb_out
{% if selfcal_local_dir is not none %}
convert_merged_selfcal_parmdbs.argument.scratch_dir = {{ selfcal_local_dir }}
{% endif %}

{% if create_preapply_parmdb %}
# make a phase-only parmDB suitable for preapplication, length = 1
create_preapply_parmdb.control.type       = reset_amps
create_preapply_parmdb.control.mapfile_in = convert_merged_selfcal_parmdbs.output.mapfile
create_preapply_parmdb.control.inputkey   = inparmdb
create_preapply_parmdb.control.outputkey  = outparmdb
create_preapply_parmdb.control.arguments  = [inparmdb,outparmdb]
{% endif %}

# make plots of the selfcal solutions from the merged parmDB, length = 1
make_selfcal_plots.control.type       = make_selfcal_plots
make_selfcal_plots.control.mapfile_in = merge_selfcal_parmdbs.output.mapfile
make_selfcal_plots.control.inputkeys  = parmdb
make_selfcal_plots.control.outputkey  = plots_root
make_selfcal_plots.argument.flags     = [parmdb,plots_root]
make_selfcal_plots.argument.fourpol   = {{ fourpol }}

# create a mapfile with the selfcal images, length = 1
create_selfcal_images_mapfile.control.kind        = plugin
create_selfcal_images_mapfile.control.type        = addSelfcalImagesMapfile
create_selfcal_images_mapfile.control.selfcal_dir = {{ pipeline_parset_dir }}
create_selfcal_images_mapfile.control.mapfile_dir = input.output.mapfile_dir
create_selfcal_images_mapfile.control.hosts       = {{ hosts }}
create_selfcal_images_mapfile.control.filename    = selfcal_images.mapfile

# make plots of the selfcal images, length = 1
make_selfcal_images.control.type       = make_selfcal_images
make_selfcal_images.control.mapfile_in = create_selfcal_images_mapfile.output.mapfile
make_selfcal_images.control.inputkeys  = imagefiles
make_selfcal_images.argument.flags     = [imagefiles]

# expand the merged parmDB to all files, length = nfiles
expand_merged_parmdb_map.control.kind             = plugin
expand_merged_parmdb_map.control.type             = expandMapfile
expand_merged_parmdb_map.control.mapfile_in       = convert_merged_selfcal_parmdbs.output.mapfile
expand_merged_parmdb_map.control.mapfile_to_match = shift_cal.output.mapfile
expand_merged_parmdb_map.control.mapfile_dir      = input.output.mapfile_dir
expand_merged_parmdb_map.control.filename         = expand_merged_parmdbs.mapfile

# create a mapfile for the last calibrator sky model, length = 1
create_model4_map.control.kind        = plugin
create_model4_map.control.type        = trimMapfile
create_model4_map.control.mapfile_in  = wsclean_image42.output.wsclean_image42-model.fits.mapfile
create_model4_map.control.trim        = -
create_model4_map.control.mapfile_dir = input.output.mapfile_dir
create_model4_map.control.filename    = final_model_rootnames.mapfile

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_model4_map.control.kind             = plugin
expand_model4_map.control.type             = expandMapfile
expand_model4_map.control.mapfile_in       = create_model4_map.output.mapfile
expand_model4_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_model4_map.control.mapfile_dir      = input.output.mapfile_dir
expand_model4_map.control.filename         = expand_model4_map.mapfile

# Blank (with zeros) regions of the mask that lie outside of the patch region, length = 1
blank_mask.control.type                    = blank_image
blank_mask.control.mapfile_in              = premask_selfcal.output.mapfile
blank_mask.control.inputkey                = infile
blank_mask.control.outputkey               = outfile
blank_mask.argument.flags                  = [infile,{{ vertices_file }},outfile]
blank_mask.argument.blank_value            = zero
blank_mask.argument.image_is_wsclean_model = False

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_mask4_map.control.kind             = plugin
expand_mask4_map.control.type             = expandMapfile
expand_mask4_map.control.mapfile_in       = blank_mask.output.mapfile
expand_mask4_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_mask4_map.control.mapfile_dir      = input.output.mapfile_dir
expand_mask4_map.control.filename         = expand_mask4_map.mapfile

# make the new calibrator sky model, len = nbands
make_new_cal_skymodel.control.type        = poly2sky
make_new_cal_skymodel.control.mapfiles_in = [create_msmulti_map.output.mapfile,expand_model4_map.output.mapfile,expand_mask4_map.output.mapfile]
make_new_cal_skymodel.control.inputkeys   = [msfile,rootname,mask]
make_new_cal_skymodel.control.outputkey   = skymodel
make_new_cal_skymodel.argument.flags      = [rootname,msfile,skymodel,mask]

{% if not is_patch or wsclean_selfcal_multiscale %}
# Image the full facet at high-res to improve the model (if direction is a patch,
# and wsclean_selfcal_multiscale is True, we do this but skip the high-res imaging
# as we already have such an image from selfcal)

# extract the skymodel for the full facet from global skymodel, length = nbands
make_facet_skymodels_all.control.type       = make_facet_skymodel
make_facet_skymodels_all.control.mapfile_in = create_full_skymodels_map.output.mapfile
make_facet_skymodels_all.control.inputkey   = fullmodelfile
make_facet_skymodels_all.control.outputkey  = outfile
make_facet_skymodels_all.argument.flags     = [fullmodelfile,outfile,{{ vertices_file }}]

# convert the facet skymodel into a sourcedb, length = nbands
make_sourcedb_all_facet_sources.control.type       = make_sourcedb
make_sourcedb_all_facet_sources.control.mapfile_in = make_facet_skymodels_all.output.mapfile
make_sourcedb_all_facet_sources.control.inputkey   = in
make_sourcedb_all_facet_sources.argument.format    = <
make_sourcedb_all_facet_sources.argument.outtype   = blob
make_sourcedb_all_facet_sources.argument.append    = False

# expand the dir-indep sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_all_facet_sources.control.kind           = plugin
expand_sourcedb_all_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_all_facet_sources.control.mapfile_in     = make_sourcedb_all_facet_sources.output.mapfile
expand_sourcedb_all_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_all_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_all_facet_sources.control.filename       = expand_sourcedb_all_facet_sources.mapfile

# shift the empty data, add all facet sources, apply the direction-dependent solutions and average, length = nfiles or nbands_selfcal_facet_image * nchunks
# compress data and weights
prepare_imaging_data.control.type                                 = dppp
prepare_imaging_data.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_all_facet_sources.output.mapfile,create_parmdb_map.output.mapfile,expand_merged_parmdb_map.output.mapfile]
prepare_imaging_data.control.inputkeys                            = [msin,sourcedb,dir_indep_parmdb,dir_dep_parmdb]
prepare_imaging_data.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
prepare_imaging_data.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
prepare_imaging_data.argument.msin.startchan                      = {{ startchan_selfcal_facet_image }}
prepare_imaging_data.argument.msin.nchan                          = {{ nchan_selfcal_facet_image }}
prepare_imaging_data.argument.msout.overwrite                     = True
prepare_imaging_data.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
prepare_imaging_data.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
prepare_imaging_data.argument.steps                               = [shift,add,flag,correct,flagzero,avg]
{% else %}
prepare_imaging_data.argument.steps                               = [shift,add,correct,flagzero,avg]
{% endif %}
prepare_imaging_data.argument.shift.type                          = phaseshifter
prepare_imaging_data.argument.shift.phasecenter                   = [{{ facet_ra }}deg, {{ facet_dec }}deg]
prepare_imaging_data.argument.add.type                            = predict
prepare_imaging_data.argument.add.sourcedb                        = sourcedb
prepare_imaging_data.argument.add.operation                       = add
prepare_imaging_data.argument.add.applycal.parmdb                 = dir_indep_parmdb
{% if flag_abstime is not none or flag_baseline is not none or flag_freqrange is not none %}
prepare_imaging_data.argument.flag.type                           = preflagger
prepare_imaging_data.argument.flag.expr                           = {{ flag_expr }}
{% endif %}
{% if flag_abstime is not none %}
prepare_imaging_data.argument.flag.flag_abstime.abstime           = {{ flag_abstime }}
{% endif %}
{% if flag_baseline is not none %}
prepare_imaging_data.argument.flag.flag_baseline.baseline         = {{ flag_baseline }}
{% endif %}
{% if flag_freqrange is not none %}
prepare_imaging_data.argument.flag.flag_freqrange.freqrange       = {{ flag_freqrange }}
{% endif %}
prepare_imaging_data.argument.correct.type                        = applycal
prepare_imaging_data.argument.correct.parmdb                      = dir_dep_parmdb
prepare_imaging_data.argument.correct.invert                      = True
prepare_imaging_data.argument.flagzero.type                       = preflagger
prepare_imaging_data.argument.flagzero.amplmin                    = 1e-20
prepare_imaging_data.argument.avg.type                            = squash
prepare_imaging_data.argument.avg.freqstep                        = {{ facetimage_freqstep }}
prepare_imaging_data.argument.avg.timestep                        = {{ facetimage_timestep }}
{% if use_compression %}
prepare_imaging_data.argument.msout.storagemanager                = "Dysco"
prepare_imaging_data.argument.msout.storagemanager.databitrate    = 16
prepare_imaging_data.argument.msout.storagemanager.weightbitrate  = 12
prepare_imaging_data.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
prepare_imaging_data.argument.msout.storagemanager.disttruncation = 1.5
prepare_imaging_data.argument.msout.storagemanager.normalization  = "AF"
# {% endif %}

{% if not is_patch %}
# Now make the high-res facet image

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile5.control.kind        = plugin
create_compressed_mapfile5.control.type        = compressMapfile
create_compressed_mapfile5.control.mapfile_in  = prepare_imaging_data.output.mapfile
create_compressed_mapfile5.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile5.control.filename    = concat_averaged_input.mapfile

# make a facet clean mask from the last selfcal image, length = 1
premask.control.type                   = make_clean_mask
premask.control.mapfile_in             = create_imagebase_map42.output.mapfile
premask.control.inputkey               = imagefile
premask.control.outputkey              = maskfile
premask.argument.flags                 = [imagefile,maskfile]
premask.argument.img_format            = fits
premask.argument.pad_to_size           = {{ facet_imsize }}
premask.argument.skip_source_detection = True
premask.argument.vertices_file         = {{ vertices_file }}
premask.argument.reference_ra_deg      = {{ facet_ra }}
premask.argument.reference_dec_deg     = {{ facet_dec }}

# image the concatenated data with the preliminary mask, length = 1
wsclean_image_full.control.type                   = wsclean
wsclean_image_full.control.mapfiles_in            = [create_compressed_mapfile5.output.mapfile,premask.output.mapfile]
wsclean_image_full.control.inputkeys              = [msfile,fitsmask]
{% if nbands_selfcal_facet_image > 1 %}
wsclean_image_full.argument.flags                 = [-no-update-model-required,-fitbeam,-reorder,-joinchannels,-multiscale,-save-source-list,-local-rms,msfile]
wsclean_image_full.argument.channelsout           = {{ nbands_selfcal_facet_image }}
{% else %}
wsclean_image_full.argument.flags                 = [-no-update-model-required,-fitbeam,-reorder,-multiscale,-save-source-list,-local-rms,msfile]
{% endif %}
wsclean_image_full.argument.fitsmask              = fitsmask
wsclean_image_full.argument.size                  = {{ facet_imsize }} {{ facet_imsize }}
wsclean_image_full.argument.niter                 = {{ wsclean_selfcal_full_image_niter }}
wsclean_image_full.argument.pol                   = I
wsclean_image_full.argument.weight                = briggs {{ robust_selfcal }}
wsclean_image_full.argument.mgain                 = 0.8
wsclean_image_full.argument.minuv-l               = {{ facet_min_uv_lambda }}
wsclean_image_full.argument.scale                 = {{ cellsize_selfcal_deg }}
wsclean_image_full.argument.mem                   = {{ max_percent_memory_per_proc_single }}
wsclean_image_full.argument.j                     = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image_full.argument.tempdir               = {{ local_dir_parent }}
{% endif %}
{% if nbands_selfcal_facet_image > 3 %}
wsclean_image_full.argument.fit-spectral-pol      = 3
{% elif nbands_selfcal_facet_image > 1 %}
wsclean_image_full.argument.fit-spectral-pol      = {{ nbands_selfcal_facet_image - 1 }}
{% endif %}
wsclean_image_full.argument.multiscale-scales     = 0
wsclean_image_full.argument.weighting-rank-filter = 3
{% if facetimage_wsclean_nwavelengths > 0.0 %}
wsclean_image_full.argument.baseline-averaging    = {{ facetimage_wsclean_nwavelengths }}
{% endif %}
wsclean_image_full.argument.auto-mask             = 3
wsclean_image_full.argument.auto-threshold        = 1.0
wsclean_image_full.argument.local-rms-window      = 50
wsclean_image_full.argument.local-rms-method      = rms-with-min

# make a mapfile with the root-name of the WSClean images, length = 1
create_imagebase_map.control.kind        = plugin
create_imagebase_map.control.type        = trimMapfile
create_imagebase_map.control.mapfile_in  = wsclean_image_full.output.wsclean_image_full-image.fits.mapfile
create_imagebase_map.control.trim        = -
create_imagebase_map.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_map.control.filename    = wsclean_image_full_image_rootnames.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile1.control.kind        = plugin
adjust_wsclean_mapfile1.control.type        = appendMapfile
adjust_wsclean_mapfile1.control.mapfile_in  = create_imagebase_map.output.mapfile
adjust_wsclean_mapfile1.control.append      = {{ wsclean_selfcal_facet_image_suffix }}
adjust_wsclean_mapfile1.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile1.control.filename    = final_image1.mapfile

# make a mask from the updated image, length = 1
# we use high thresholds to pick up only the brightest sources and exclude artifacts
mask5.control.type                = make_clean_mask
mask5.control.mapfile_in          = adjust_wsclean_mapfile1.output.mapfile
mask5.control.inputkey            = imagefile
mask5.control.outputkey           = maskfile
mask5.argument.flags              = [imagefile,maskfile]
mask5.argument.region_file        = {{ region_field }}
mask5.argument.threshisl          = 6
mask5.argument.threshpix          = 8
mask5.argument.rmsbox             = (80,20)
mask5.argument.adaptive_rmsbox    = True
mask5.argument.atrous_do          = False
mask5.argument.img_format         = fits
mask5.argument.vertices_file      = {{ vertices_file }}
mask5.argument.exclude_cal_region = True
mask5.argument.dilate             = 2

# check the mask6 output and modify its mapfile if no sources were found, length = 1
check_mask_high.control.kind          = plugin
check_mask_high.control.type          = checkMapfile
check_mask_high.control.mapfile_in    = mask5.output.mapfile
check_mask_high.control.mapfile_check = mask5.output.threshold_5sig.mapfile
check_mask_high.control.mapfile_dir   = input.output.mapfile_dir
check_mask_high.control.filename      = check_mask5_map.mapfile

# make a mapfile with the root-name of the final WSClean images, length = 1
create_model5_map.control.kind        = plugin
create_model5_map.control.type        = trimMapfile
create_model5_map.control.mapfile_in  = wsclean_image_full.output.wsclean_image_full-model.fits.mapfile
create_model5_map.control.trim        = -
create_model5_map.control.mapfile_dir = input.output.mapfile_dir
create_model5_map.control.filename    = final_model_rootnames.mapfile

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_model5_map.control.kind             = plugin
expand_model5_map.control.type             = expandMapfile
expand_model5_map.control.mapfile_in       = create_model5_map.output.mapfile
expand_model5_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_model5_map.control.mapfile_dir      = input.output.mapfile_dir
expand_model5_map.control.filename         = expand_model5_map.mapfile

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_mask5_map.control.kind             = plugin
expand_mask5_map.control.type             = expandMapfile
expand_mask5_map.control.mapfile_in       = mask5.output.mapfile
expand_mask5_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_mask5_map.control.mapfile_dir      = input.output.mapfile_dir
expand_mask5_map.control.filename         = expand_mask5_map.mapfile

# make high-res full-facet sky model, using mask above, len = nbands
make_high_facet_skymodel.control.type        = poly2sky
make_high_facet_skymodel.control.mapfiles_in = [create_msmulti_map.output.mapfile,expand_model5_map.output.mapfile,expand_mask5_map.output.mapfile]
make_high_facet_skymodel.control.inputkeys   = [msfile,rootname,mask]
make_high_facet_skymodel.control.outputkey   = skymodel
make_high_facet_skymodel.argument.flags      = [rootname,msfile,skymodel,mask]

# combine the new calibrator and facet sky models, length = nbands
combine_skymodels_high.control.type        = combine_skymodels
combine_skymodels_high.control.mapfiles_in = [make_high_facet_skymodel.output.mapfile,make_new_cal_skymodel.output.mapfile]
combine_skymodels_high.control.inputkeys   = [newfacetmodel,calmodel]
combine_skymodels_high.control.outputkey   = skymodel
combine_skymodels_high.argument.flags      = [calmodel,newfacetmodel,skymodel]

# end of high-res full facet imaging
{% endif %}

# Make a medium-res image of the facet or (if wsclean_selfcal_multiscale is True)
# of the calibrator region to pick up any extended emission missed in the high-
# res image

# convert the combined sky model into a sourcedb, length = nbands
make_sourcedb_high.control.type       = make_sourcedb
{% if is_patch %}
make_sourcedb_high.control.mapfile_in = make_new_cal_skymodel.output.mapfile
{% else %}
make_sourcedb_high.control.mapfile_in = combine_skymodels_high.output.mapfile
{% endif %}
make_sourcedb_high.control.inputkey   = in
make_sourcedb_high.argument.format    = <
make_sourcedb_high.argument.outtype   = blob
make_sourcedb_high.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_high.control.kind           = plugin
expand_sourcedb_high.control.type           = mapfileSingleToGroup
expand_sourcedb_high.control.mapfile_in     = make_sourcedb_high.output.mapfile
expand_sourcedb_high.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_high.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_high.control.filename       = expand_sourcedb_high.mapfile

# subtract the high-resolution model, length = nfiles or nbands_selfcal_facet_image * nchunks
# compress data and weights
subtract_high.control.type                                 = dppp
subtract_high.control.mapfiles_in                          = [prepare_imaging_data.output.mapfile,expand_sourcedb_high.output.mapfile]
subtract_high.control.inputkeys                            = [msin,sourcedb_high]
subtract_high.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
subtract_high.argument.msin.datacolumn                     = DATA
subtract_high.argument.msout.overwrite                     = True
subtract_high.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
subtract_high.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
subtract_high.argument.steps                               = [subtract,avg]
subtract_high.argument.subtract.type                       = predict
subtract_high.argument.subtract.sourcedb                   = sourcedb_high
subtract_high.argument.subtract.operation                  = subtract
subtract_high.argument.avg.type                            = squash
subtract_high.argument.avg.freqstep                        = {{ facetimage_low_freqstep }}
subtract_high.argument.avg.timestep                        = {{ facetimage_low_timestep }}
{% if use_compression %}
subtract_high.argument.msout.storagemanager                = "Dysco"
subtract_high.argument.msout.storagemanager.databitrate    = 0
subtract_high.argument.msout.storagemanager.weightbitrate  = 12
subtract_high.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
subtract_high.argument.msout.storagemanager.disttruncation = 1.5
subtract_high.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# compress mapfile so that all files are in one group, length = 1
create_compressed_mapfile6.control.kind        = plugin
create_compressed_mapfile6.control.type        = compressMapfile
create_compressed_mapfile6.control.mapfile_in  = subtract_high.output.mapfile
create_compressed_mapfile6.control.mapfile_dir = input.output.mapfile_dir
create_compressed_mapfile6.control.filename    = concat_averaged_med_input.mapfile

# Make a facet clean mask from the facet region, length = 1
premask_med.control.type                   = make_clean_mask
premask_med.control.mapfile_in             = create_compressed_mapfile6.output.mapfile
premask_med.control.inputkey               = imagefile
premask_med.control.outputkey              = maskfile
premask_med.argument.flags                 = [imagefile,maskfile]
premask_med.argument.img_format            = fits
premask_med.argument.pad_to_size           = {{ facet_med_imsize }}
premask_med.argument.skip_source_detection = True
premask_med.argument.vertices_file         = {{ vertices_file }}
premask_med.argument.reference_ra_deg      = {{ facet_ra }}
premask_med.argument.reference_dec_deg     = {{ facet_dec }}
premask_med.argument.cellsize_deg          = {{ cellsize_facet_med_deg }}
premask_med.argument.make_blank_image      = True

# image the concatenated data with the preliminary mask at med resolution, length = 1
wsclean_image_full_med.control.type                   = wsclean
wsclean_image_full_med.control.mapfiles_in            = [create_compressed_mapfile6.output.mapfile,premask_med.output.mapfile]
wsclean_image_full_med.control.inputkeys              = [msfile,fitsmask]
{% if nbands_selfcal_facet_image > 1 %}
wsclean_image_full_med.argument.flags                 = [-no-update-model-required,-fitbeam,-reorder,-joinchannels,-multiscale,-save-source-list,-local-rms,msfile]
wsclean_image_full_med.argument.channelsout           = {{ nbands_selfcal_facet_image }}
{% else %}
wsclean_image_full_med.argument.flags                 = [-no-update-model-required,-fitbeam,-reorder,-multiscale,-save-source-list,-local-rms,msfile]
{% endif %}
wsclean_image_full_med.argument.fitsmask              = fitsmask
wsclean_image_full_med.argument.size                  = {{ facet_med_imsize }} {{ facet_med_imsize }}
wsclean_image_full_med.argument.niter                 = {{ wsclean_selfcal_full_image_niter }}
wsclean_image_full_med.argument.pol                   = I
wsclean_image_full_med.argument.weight                = briggs 0.0
wsclean_image_full_med.argument.mgain                 = 0.8
wsclean_image_full_med.argument.minuv-l               = {{ facet_min_uv_lambda }}
wsclean_image_full_med.argument.taper-gaussian        = {{ cellsize_facet_med_deg*3600*3 }}arcsec
wsclean_image_full_med.argument.scale                 = {{ cellsize_facet_med_deg }}
wsclean_image_full_med.argument.mem                   = {{ max_percent_memory_per_proc_single }}
wsclean_image_full_med.argument.j                     = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_image_full_med.argument.tempdir               = {{ local_dir_parent }}
{% endif %}
wsclean_image_full_med.argument.multiscale-shape      = gaussian
{% if nbands_selfcal_facet_image > 3 %}
wsclean_image_full_med.argument.fit-spectral-pol      = 3
{% elif nbands_selfcal_facet_image > 1 %}
wsclean_image_full_med.argument.fit-spectral-pol      = {{ nbands_selfcal_facet_image - 1 }}
{% endif %}
wsclean_image_full_med.argument.weighting-rank-filter = 3
{% if facetimage_medlow_wsclean_nwavelengths > 0.0 %}
wsclean_image_full_med.argument.baseline-averaging    = {{ facetimage_medlow_wsclean_nwavelengths }}
{% endif %}
wsclean_image_full_med.argument.auto-mask             = 3
wsclean_image_full_med.argument.auto-threshold        = 0.5
wsclean_image_full_med.argument.local-rms-window      = 50
wsclean_image_full_med.argument.local-rms-method      = rms-with-min

# make a mapfile with the root-name of the WSClean images, length = 1
create_imagebase_med_map.control.kind        = plugin
create_imagebase_med_map.control.type        = trimMapfile
create_imagebase_med_map.control.mapfile_in  = wsclean_image_full_med.output.wsclean_image_full_med-image.fits.mapfile
create_imagebase_med_map.control.trim        = -
create_imagebase_med_map.control.mapfile_dir = input.output.mapfile_dir
create_imagebase_med_map.control.filename    = wsclean_image_full_med_image_rootnames.mapfile

# make a mapfile with the name of the WSClean image, length = 1
adjust_wsclean_mapfile3.control.kind        = plugin
adjust_wsclean_mapfile3.control.type        = appendMapfile
adjust_wsclean_mapfile3.control.mapfile_in  = create_imagebase_med_map.output.mapfile
adjust_wsclean_mapfile3.control.append      = {{ wsclean_selfcal_facet_image_suffix }}
adjust_wsclean_mapfile3.control.mapfile_dir = input.output.mapfile_dir
adjust_wsclean_mapfile3.control.filename    = final_image_med.mapfile

# make a mask from the updated image, length = 1
# we use high thresholds to pick up only the brightest sources and exclude artifacts
mask6.control.type                = make_clean_mask
mask6.control.mapfile_in          = adjust_wsclean_mapfile3.output.mapfile
mask6.control.inputkey            = imagefile
mask6.control.outputkey           = maskfile
mask6.argument.flags              = [imagefile,maskfile]
mask6.argument.region_file        = {{ region_field }}
mask6.argument.threshisl          = 5
mask6.argument.threshpix          = 8
mask6.argument.rmsbox             = (80,20)
mask6.argument.adaptive_rmsbox    = True
mask6.argument.atrous_do          = True
mask6.argument.img_format         = fits
mask6.argument.vertices_file      = {{ vertices_file }}
mask6.argument.exclude_cal_region = False
mask6.argument.dilate             = 2

# check the mask6 output and modify its mapfile if no sources were found, length = 1
check_mask_med.control.kind          = plugin
check_mask_med.control.type          = checkMapfile
check_mask_med.control.mapfile_in    = mask6.output.mapfile
check_mask_med.control.mapfile_check = mask6.output.threshold_5sig.mapfile
check_mask_med.control.mapfile_dir   = input.output.mapfile_dir
check_mask_med.control.filename      = check_mask6_map.mapfile

# expand the model mapfile so that there is one entry for every band, length = nbands
expand_model6_map.control.kind             = plugin
expand_model6_map.control.type             = expandMapfile
expand_model6_map.control.mapfile_in       = create_imagebase_med_map.output.mapfile
expand_model6_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_model6_map.control.mapfile_dir      = input.output.mapfile_dir
expand_model6_map.control.filename         = expand_model6_map.mapfile

# expand the mask mapfile so that there is one entry for every band, length = nbands
expand_mask6_map.control.kind             = plugin
expand_mask6_map.control.type             = expandMapfile
expand_mask6_map.control.mapfile_in       = check_mask_med.output.mapfile
expand_mask6_map.control.mapfile_to_match = create_msmulti_map.output.mapfile
expand_mask6_map.control.mapfile_dir      = input.output.mapfile_dir
expand_mask6_map.control.filename         = expand_mask6_map.mapfile

# make med-res full-facet sky model, using mask above, len = nbands
make_med_facet_skymodel.control.type        = poly2sky
make_med_facet_skymodel.control.mapfiles_in = [create_msmulti_map.output.mapfile,expand_model6_map.output.mapfile,expand_mask6_map.output.mapfile]
make_med_facet_skymodel.control.inputkeys   = [msfile,rootname,mask]
make_med_facet_skymodel.control.outputkey   = skymodel
make_med_facet_skymodel.argument.flags      = [rootname,msfile,skymodel,mask,0.0,0.0]

# combine the medium- and high-res facet sky models, length = nbands
combine_facet_skymodels.control.type        = combine_skymodels
{% if is_patch %}
combine_facet_skymodels.control.mapfiles_in = [make_new_cal_skymodel.output.mapfile,make_med_facet_skymodel.output.mapfile]
{% else %}
combine_facet_skymodels.control.mapfiles_in = [combine_skymodels_high.output.mapfile,make_med_facet_skymodel.output.mapfile]
{% endif %}
combine_facet_skymodels.control.inputkeys   = [highresmodel,medresmodel]
combine_facet_skymodels.control.outputkey   = skymodel
combine_facet_skymodels.argument.flags      = [highresmodel,medresmodel,skymodel]

# convert the combined sky model into a sourcedb, length = nbands
make_sourcedb_new_facet_sources.control.type       = make_sourcedb
make_sourcedb_new_facet_sources.control.mapfile_in = combine_facet_skymodels.output.mapfile
make_sourcedb_new_facet_sources.control.inputkey   = in
make_sourcedb_new_facet_sources.argument.format    = <
make_sourcedb_new_facet_sources.argument.outtype   = blob
make_sourcedb_new_facet_sources.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_new_facet_sources.control.kind           = plugin
expand_sourcedb_new_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_new_facet_sources.control.mapfile_in     = make_sourcedb_new_facet_sources.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_new_facet_sources.control.filename       = expand_sourcedb_new_facet_sources.mapfile

{% else %}
# for patches for which wsclean_selfcal_multiscale = False, just make a sourcedb
# from the new calibrator sky model

# convert the calibrator sky model (= facet sky model) into a sourcedb, length = nbands
make_sourcedb_new_facet_sources.control.type       = make_sourcedb
make_sourcedb_new_facet_sources.control.mapfile_in = make_new_cal_skymodel.output.mapfile
make_sourcedb_new_facet_sources.control.inputkey   = in
make_sourcedb_new_facet_sources.argument.format    = <
make_sourcedb_new_facet_sources.argument.outtype   = blob
make_sourcedb_new_facet_sources.argument.append    = False

# expand the sourcedb mapfile so that there is one entry for every file, length = nfiles
expand_sourcedb_new_facet_sources.control.kind           = plugin
expand_sourcedb_new_facet_sources.control.type           = mapfileSingleToGroup
expand_sourcedb_new_facet_sources.control.mapfile_in     = make_sourcedb_new_facet_sources.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_groups = create_msmulti_map.output.mapfile
expand_sourcedb_new_facet_sources.control.mapfile_dir    = input.output.mapfile_dir
expand_sourcedb_new_facet_sources.control.filename       = expand_sourcedb_new_facet_sources.mapfile

{% endif %}
########## end of the "is the calibrator the full facet" block

# predict the old and new models and subtract the old one from the new one, length = nfiles
# compress weights only
predict_and_difference_models.control.type                                 = dppp
{% if not is_patch %}
predict_and_difference_models.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_new_facet_sources.output.mapfile,expand_merged_parmdb_map.output.mapfile,expand_sourcedb_all_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
predict_and_difference_models.control.inputkeys                            = [msin,dir_dep_sourcedb,dir_dep_parmdb,dir_indep_sourcedb,dir_indep_parmdb]
{% else %}
predict_and_difference_models.control.mapfiles_in                          = [create_ms_map.output.mapfile,expand_sourcedb_new_facet_sources.output.mapfile,expand_merged_parmdb_map.output.mapfile,expand_sourcedb_cal_facet_sources.output.mapfile,create_parmdb_map.output.mapfile]
predict_and_difference_models.control.inputkeys                            = [msin,dir_dep_sourcedb,dir_dep_parmdb,dir_indep_sourcedb,dir_indep_parmdb]
{% endif %}
predict_and_difference_models.argument.numthreads                          = {{ max_cpus_per_io_proc_nfiles }}
predict_and_difference_models.argument.msin.datacolumn                     = DATA
predict_and_difference_models.argument.msout.overwrite                     = True
predict_and_difference_models.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
predict_and_difference_models.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
predict_and_difference_models.argument.steps                               = [pred_new,subtract_old]
predict_and_difference_models.argument.pred_new.type                       = predict
predict_and_difference_models.argument.pred_new.sourcedb                   = dir_dep_sourcedb
predict_and_difference_models.argument.pred_new.applycal.parmdb            = dir_dep_parmdb
predict_and_difference_models.argument.pred_new.operation                  = replace
predict_and_difference_models.argument.subtract_old.type                   = predict
predict_and_difference_models.argument.subtract_old.sourcedb               = dir_indep_sourcedb
predict_and_difference_models.argument.subtract_old.applycal.parmdb        = dir_indep_parmdb
predict_and_difference_models.argument.subtract_old.operation              = subtract
{% if use_compression %}
predict_and_difference_models.argument.msout.storagemanager                = "Dysco"
predict_and_difference_models.argument.msout.storagemanager.databitrate    = 0
predict_and_difference_models.argument.msout.storagemanager.weightbitrate  = 12
predict_and_difference_models.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
predict_and_difference_models.argument.msout.storagemanager.disttruncation = 1.5
predict_and_difference_models.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

#
# Verify the quality of selfcal on the middle band
#

# make a map with original facet data of only the central frequency band, length = ntimes
create_middle_band_mapfile1.control.kind        = plugin
create_middle_band_mapfile1.control.type        = selectMiddleFreq
create_middle_band_mapfile1.control.mapfile_in  = create_ms_map.output.mapfile
create_middle_band_mapfile1.control.mapfile_dir = input.output.mapfile_dir
create_middle_band_mapfile1.control.filename    = single_band_orig.mapfile

# make a map with new facet data of only the central frequency band, length = ntimes
create_middle_band_mapfile2.control.kind        = plugin
create_middle_band_mapfile2.control.type        = selectMiddleFreq
create_middle_band_mapfile2.control.mapfile_in  = predict_and_difference_models.output.mapfile
create_middle_band_mapfile2.control.mapfile_dir = input.output.mapfile_dir
create_middle_band_mapfile2.control.filename    = single_band_new.mapfile

# subtract new facet data from original data, length = ntimes
subtract_single.control.type        = add_subtract_columns
subtract_single.control.mapfiles_in = [create_middle_band_mapfile2.output.mapfile,create_middle_band_mapfile1.output.mapfile]
subtract_single.control.inputkeys   = [file1,file2]
subtract_single.argument.flags      = [file1,file2,DATA,{{ subtracted_data_colname }},MODEL_DATA,subtract21]

# average old empty data, length = ntimes
average_pre.control.type                                 = dppp
average_pre.control.mapfile_in                           = create_middle_band_mapfile1.output.mapfile
average_pre.control.inputkey                             = msin
average_pre.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
average_pre.argument.msin.datacolumn                     = {{ subtracted_data_colname }}
average_pre.argument.msout.overwrite                     = True
average_pre.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average_pre.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average_pre.argument.steps                               = [uv,avg]
average_pre.argument.uv.type                             = uvwflagger
average_pre.argument.uv.uvmmax                           = 2500.0
average_pre.argument.avg.type                            = squash
average_pre.argument.avg.freqstep                        = {{ verify_freqstep }}
average_pre.argument.avg.timestep                        = {{ verify_timestep }}
{% if use_compression %}
average_pre.argument.msout.storagemanager                = "Dysco"
average_pre.argument.msout.storagemanager.databitrate    = 16
average_pre.argument.msout.storagemanager.weightbitrate  = 12
average_pre.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average_pre.argument.msout.storagemanager.disttruncation = 1.5
average_pre.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# average "old minus new" facet data (= new empty data), length = ntimes
average_post.control.type                                 = dppp
average_post.control.mapfile_in                           = create_middle_band_mapfile2.output.mapfile
average_post.control.inputkey                             = msin
average_post.argument.numthreads                          = {{ max_cpus_per_io_proc_ntimes }}
average_post.argument.msin.datacolumn                     = MODEL_DATA
average_post.argument.msout.overwrite                     = True
average_post.argument.msout.writefullresflag              = False
{% if local_dir is not none %}
average_post.argument.local_scratch_dir                   = {{ local_dir }}
{% endif %}
average_post.argument.steps                               = [uv,avg]
average_post.argument.uv.type                             = uvwflagger
average_post.argument.uv.uvmmax                           = 2500.0
average_post.argument.avg.type                            = squash
average_post.argument.avg.freqstep                        = {{ verify_freqstep }}
average_post.argument.avg.timestep                        = {{ verify_timestep }}
{% if use_compression %}
average_post.argument.msout.storagemanager                = "Dysco"
average_post.argument.msout.storagemanager.databitrate    = 16
average_post.argument.msout.storagemanager.weightbitrate  = 12
average_post.argument.msout.storagemanager.distribution   = "TruncatedGaussian"
average_post.argument.msout.storagemanager.disttruncation = 1.5
average_post.argument.msout.storagemanager.normalization  = "AF"
{% endif %}

# make compressed mapfile of old empty data, length = 1
average_pre_compressed_map.control.kind        = plugin
average_pre_compressed_map.control.type        = compressMapfile
average_pre_compressed_map.control.mapfile_in  = average_pre.output.mapfile
average_pre_compressed_map.control.mapfile_dir = input.output.mapfile_dir
average_pre_compressed_map.control.filename    = average_pre_compressed.mapfile

# image the old empty data, length = 1
wsclean_pre.control.type         = wsclean
wsclean_pre.control.mapfile_in   = average_pre_compressed_map.output.mapfile
wsclean_pre.control.inputkey     = msfiles
wsclean_pre.argument.flags       = [-no-update-model-required,msfiles]
wsclean_pre.argument.size        = 2048 2048
wsclean_pre.argument.niter       = 10
wsclean_pre.argument.threshold   = 0.0
wsclean_pre.argument.pol         = I
wsclean_pre.argument.weight      = briggs -0.5
wsclean_pre.argument.mgain       = 0.8
wsclean_pre.argument.gain        = 0.1
wsclean_pre.argument.minuv-l     = {{ facet_min_uv_lambda }}
wsclean_pre.argument.maxuv-l     = 2500
wsclean_pre.argument.scale       = 0.00833
wsclean_pre.argument.mem         = {{ max_percent_memory_per_proc_single }}
wsclean_pre.argument.j           = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_pre.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

# make compressed mapfile of new empty data, length = 1
average_post_compressed_map.control.kind        = plugin
average_post_compressed_map.control.type        = compressMapfile
average_post_compressed_map.control.mapfile_in  = average_post.output.mapfile
average_post_compressed_map.control.mapfile_dir = input.output.mapfile_dir
average_post_compressed_map.control.filename    = average_post_compressed.mapfile

# image the new empty data, length = 1
wsclean_post.control.type         = wsclean
wsclean_post.control.mapfile_in   = average_post_compressed_map.output.mapfile
wsclean_post.control.inputkey     = msfiles
wsclean_post.argument.flags       = [-no-update-model-required,msfiles]
wsclean_post.argument.size        = 2048 2048
wsclean_post.argument.niter       = 10
wsclean_post.argument.threshold   = 0.0
wsclean_post.argument.pol         = I
wsclean_post.argument.weight      = briggs -0.5
wsclean_post.argument.mgain       = 0.8
wsclean_post.argument.gain        = 0.1
wsclean_post.argument.minuv-l     = {{ facet_min_uv_lambda }}
wsclean_post.argument.maxuv-l     = 2500
wsclean_post.argument.scale       = 0.00833
wsclean_post.argument.mem         = {{ max_percent_memory_per_proc_single }}
wsclean_post.argument.j           = {{ max_cpus_per_proc_single }}
{% if local_dir is not none %}
wsclean_post.argument.tempdir     = {{ local_dir_parent }}
{% endif %}

# do a "verify_subtract" on the two "empty" images, length = 1
verify_subtract.control.type        = verify_subtract
verify_subtract.control.mapfiles_in = [wsclean_pre.output.wsclean_pre-image.fits.mapfile,wsclean_post.output.wsclean_post-image.fits.mapfile]
verify_subtract.control.inputkeys   = [image_pre,image_post]
verify_subtract.argument.flags      = [image_pre,image_post,0.75]
